\\
\\ Virtualization-Assisted Memory Protections
\\


								\\ VGA display

\ VGA test buffer
1000 aligned
:: 'vga	adr 1000 allot 'vga 1000 0 fill				\ Arena contains logical objects
: vga	baremetal? if 0b8000 else 'vga then ;
\ VGA positioning
: line	a0 * + ;
: col	1 shl + ;

\ Number display
: nibble	0f and ;
: >nibble	4 sar ;
: nibble>char	| 0a >= if [char] A [char] 9 - 1- + then [char] 0 + ;
: .n								\ ( a color nibble -- a-2 ) 
	0f and nibble>char
	{ 8 shl } or
	>< |{ 2! } 2 + ;
: .b	||{{  4 sar .n } } .n ;					\ ( a color byte -- )
: .w	||{{  8 sar .b } } .b ;					\ ( a color word -- )
: .d	||{{ 10 sar .w } } .w ;					\ ( a color qword -- )
: .q	||{{ 20 sar .d } } .d ;					\ ( a color dword -- )
: .c	{ 8 shl } or >< | { 2! } 2 + ;				\ ( a color char -- a+2 )	Display character
: .bl	20 .c ;							\ ( a color -- a+2 )	 	Display blank character
: .c'	c@ .c ;							\ ( a color 'c -- a+2 )		Fetch and display character
: .t count for ||{{ .c' }} 1+ over _ _ ;			\ ( a color 'c u -- a+2*u )	Display string

\ VGA colors
: igreen	1 emit 2f emit ;	
: iblue		1 emit 3f emit ;	
: ipurple	1 emit 5f emit ;	
: ired		1 emit 4f emit ;	

\ Page allocation

1000	:: #page val						\ Page size
: page								\ ( "<name>" -- )		Creates page-aligned zero-filled buffer
	here #page aligned here! here #page allot 
	:: val
	latest execute #page 0 fill ;

\ Scratch playground for code generation
:: scratch code
page 'scratch

INTERPRETING ' scratch behavior 				\ Scratch code points to 4K aligned scratch area
>< _ 'scratch ><
INTERPRETING ' scratch does

: <scratch here 'scratch here! ;
: scratch> ret, here! ;

: asm( <scratch ;
: )asm scratch> scratch ;


: .scratch	'scratch 40 dump ;

\\ CR and MSR

: cr0	asm( |, 0f ` 20 ` c1 ` )asm ;
: cr3	asm( |, 0f ` 20 ` d9 ` )asm ;
: cr4	asm( |, 0f ` 20 ` e1 ` )asm ;

: cr0!	asm( 0f ` 22 ` c1 ` _, )asm ;
: cr3!	asm( 0f ` 22 ` d9 ` _, )asm ;
: cr4!	asm( 0f ` 22 ` e1 ` _, )asm ;

: msr	20 >< asm( 0f ` 32 ` _, rdx shl, rax rdx or, r0 rax mov, )asm   ;
: msr!  asm( rcx push, _,  rdx rdx xor, rax rcx mov, rcx pop,  0f ` 30 ` _, )asm ;

:: cs	code |, cs, ret,				\ ( -- cs )	mov 	ecx, cs
:: ds	code |, ds, ret,				\ ( -- ds )	mov	ecx, ds

:: sp	code |, rtop rsp mov, ret,	


:: dt adr 0 2, 0 ,
: dt@ dt 2@ dt 2 + @ ;
: gdt@	dt asm( 0f ` 01 ` 01 ` )asm _ dt@ ;		\ ( -- seg base ) Returns GDTR
: idt@	dt asm( 0f ` 01 ` 09 ` )asm _ dt@ ;		\ ( -- seg base ) Returns IDTR
: tr@   dt asm( 67 ` 0f ` 00 ` 09 ` )asm _ dt@ ;	\ ( -- seg base ) Returns TR

\ MSRs and Control Registers {{{1
\ MSRs
c0000080 :: EFER val	
c0000081 :: STAR val
c0000082 :: LSTAR val
c0000083 :: CSTAR val
c0000083 :: FMASK val
c0000100 :: FS_BASE val
c0000101 :: GS_BASE val
c0000102 :: KERNEL_GS_BASE val
c0000103 :: TSC_AUX val

0000003a :: FCTL val	0000048b :: CTL2 val	00000480 :: VBAS val
00000486 :: VM0S val	00000487 :: VM0R val	00000488 :: VM4S val	00000489 :: VM4R val	


\ CR0 fields
80000000 :: PG val	00040000 :: AM val	00010000 :: WP val	00000001 :: PE val
\ CR4 fields
00002000 :: VMXE val	00100000 :: SMEP val	00200000 :: SMAP val	00800000 :: CET val
00400000 :: PKE val	01000000 :: PKS val     00000020 :: PAE	val	00020000 :: PCIDE val
\ EFER fields
00000001 :: SCE val	00000100 :: LME val	00000400 :: LMA val	00000000 :: NXE val
\ FCTL fields
00100000 :: LMCE val	00000001 :: VME val	00000002 :: VMSXE val	00000004 :: VMNSXE val
\ }}}

\ Register display {{{1
: reg@	 |, rtop >< mov, ;

: .regname							\ ( a color r -- a+2 )
	" AXCXBXDXSPBPSIDIR8 9101112131415" 1+ >< 2* + 
	| c@ >< { >| { .c } }  1+ c@ .c ;
: .regs 10 
	for	vga I 1- line 3e col      
		30  I 1- .regname 
		2f  asm( I 1- reg@ )asm .q _
	over ;

: .cregs
	vga 0 line 1c col 3f " VM0S " .t  2f VM0S msr .d _
	vga 1 line 1c col 3f " VM0R " .t  2f VM0R msr .d _
	vga 2 line 1c col 3f " CR0  " .t  2f cr0 | { .d _ }
	| { PG and if vga 3 line 1c col 30 " PG" .t 30 .bl _ then }
	| { AM and if vga 3 line 1f col 30 " AM" .t 30 .bl _ then }
	| { WP and if vga 3 line 22 col 30 " WP" .t 30 .bl _ then }
	| { PE and if vga 3 line 25 col 30 " PE" .t 30 .bl _ then }
	_
	vga 4 line 1c col 3f " VM4S " .t  2f VM4S msr .d _
	vga 5 line 1c col 3f " VM4R " .t  2f VM4R msr .d _
	vga 6 line 1c col 3f " CR4  " .t  2f cr4 | { .d _ }
	| { PAE   and if vga 7 line 1c col 30 " PAE"   .t 30 .bl _ then }
	| { VMXE  and if vga 7 line 20 col 30 " VMXE"  .t 30 .bl _ then }
	_
	vga 8 line 1c col 3f " EFER " .t  2f EFER msr  | { .d _ }
	| { LME  and if vga 9 line 1c col 30 " LME"  .t 30 .bl _ then }
	| { LMA  and if vga 9 line 20 col 30 " LMA"  .t 30 .bl _ then }
	| { NXE  and if vga 9 line 24 col 30 " NXE"  .t 30 .bl _ then }
	_
	vga a line 1c col 3f " CTL2 " .t  2f CTL2 msr | { .d _ }
	_
	vga b line 1c col 3f " FCTL " .t  2f FCTL msr | { .d _ }
	\ | { LMCE    and if vga 9 line 1c col 30 " LMCE"  .t 30 .bl then _ }
	| { VME     and if vga c line 1c col 30 " VME"  .t 30 .bl _ then }
	| { VMNSXE  and if vga c line 20 col 30 " VMNSXE"  .t 30 .bl _ then }
	| { VMSXE   and if vga c line 26 col 30 " VMSXE"  .t 30 .bl _ then }
	_
	vga d line 1c col 3f " VBAS " .t  2f VBAS msr | { .q _ }
	_
	;
\ }}}

\\ Page tables, EPT, selectors TSS etc
\ 80_000 :: PT_ADDR val						\ 512 KB
 90_000 :: TSS_ADDR val
100_000 :: BASE_ADDR val					\ 1 MB
103_000 :: FORTH_ADDR val					\ can change, here it's for reference only
200_000 :: EPT_ADDR val
304_000 :: HOST_STACK val
404_000 :: GUEST_STACK val
504_000 :: USER_STACK val
800_000 :: KERNEL_PT_ADDR val
a00_000 :: reg-save val

10	:: HOST_CS val						\ Hypervisor CS
10	:: GUEST_CS val						\ Guest CS before it loads new GDT
20	:: SUPERVISOR_CS val					\ Supervisor CS (= gust with new GDT)
33	:: USER_CS val						\ User app CS


\\ Guest general purpose register save area

\ page reg-save
reg-save 100 + :: 'reg-save-sp val
reg-save 100 + 8 + :: 'reg-save-guest-sp val

: mov-[]rsp,	48 ` 89 ` 24 ` 25 ` ;
: mov-rsp[],	48 ` 8b ` 24 ` 25 ` ; 

: pusha,
		\ mov-[]rsp, 'reg-save-guest-sp 4,
		rsp 'reg-save-sp mov.i,
		0 push,  1 push,  2 push,  3 push,
		         5 push,  6 push,  7 push,
		8 push,  9 push,  a push,  b push,
		c push,  d push,  e push,  f push, 
		rsp HOST_STACK  mov.i,
		;

: popa,
		\ mov-[]rsp, 'reg-save-guest-sp 4,
		rsp 'reg-save-sp f 8 * - mov.i,
		f pop,  e pop,  2 pop,  c pop,
		b pop,  a pop,  9 pop,  8 pop,
		7 pop,  6 pop,  5 pop,	
		3 pop,  2 pop,  1 pop,  0 pop, 
		\ mov-rsp[], 'reg-save-guest-sp 4,
		;

\\ VM
\ Instructions

: vmres,	setc, xchg01, setz, |, r0 rdx mov, ;		\ ( -- 0 0 success |  0 1 -- fail invalid | 1 0 -- fail valid )

\\ :: (vmread)	code  0f ` 78 ` c8 ` vmres,			\ ( vm-field -- value ZF CF )		Reads field from current VMCS
\\		|, r0 rax mov, ret, 
: vmread	(vmread) <<< ;

:: invept	code						\ ( eptp --  )	 	invept rax, [rcx]
		rax 1 mov.i, 66 ` 0f ` 38 ` 80 ` 01 ` vmres, ret, 		
:: vmxon 	code 67 ` f3 ` 0f ` c7 ` 31 ` vmres, ret,
:: vmclear 	code 66 ` 0f ` c7 ` 31 ` vmres, ret,
:: vmptrld 	code 0f ` c7 ` 31 ` vmres, ret,
:: vmxoff	code 0f ` 01 ` c4 ` ret,
:: vmlaunch	code 0f ` 01 ` c2 ` vmres, ret,
:: vmresume	code 0f ` 01 ` c3 ` vmres, ret,
:: vmresumea	code popa, 0f ` 01 ` c3 ` vmres, ret,
:: vmcall	code 0f ` 01 ` c1 `  ret,

:: (vmwrite)	code rax r0 mov, _,				\ ( value vm-field -- value ZF CF )	Writes field to current VMCS
		0f ` 79 ` c1 ` vmres, ret,
: vmwrite	<<< (vmwrite) -1 <<< ;

: 2mask		| 20 sar >< 0fffffff and >< >>> and or ;	\ ( v 64-bit-msr-mask-32-set-32-reset -- masked-v )

\ VM exit reasons

 0 :: VMEXIT_EXC val
12 :: VMEXIT_VMCALL val
25 :: VMEXIT_MTF val
30 :: VMEXIT_EPT val

\ VMCS fields
: high		2* 1 or ;
: full		2* ;

: control 	;
: vmexit	1 #10 bits set ;
: guest		2 #10 bits set ;
: host		3 #10 bits set ;

: 16bit		;
: 32bit		2 #13 bits set ;
: 64bit		1 #13 bits set ;
: natural	3 #13 bits set ;


0	full 64bit vmexit	:: vmexit_gpa val
0	full 32bit vmexit 	:: vminstruction_error val	\ Table B-9.; Table 32-1. VM-Instruction Error Numbers
1	full 32bit vmexit	:: vmexit_reason val		\ Table B-13.
2	full 32bit vmexit	:: vmexit_int_info val
3	full 32bit vmexit	:: vmexit_int_errcode val
4	full 32bit vmexit	:: vmexit_idt_info val
5	full 32bit vmexit	:: vmexit_idt_errcode val
6	full 32bit vmexit	:: vmexit_instr_len val
7	full 32bit vmexit	:: vmexit_instr_info val
0	full natural vmexit	:: vmexit_qualification val
4	full natural vmexit	:: vmexit_rip val
5	full natural vmexit	:: vmexit_gva val

3	full 64bit control	:: vmexit_msr_store_addr val
7	full 32bit control	:: vmexit_msr_store_count val

4	full 64bit control	:: vmexit_msr_load_addr val
8	full 32bit control	:: vmexit_msr_load_count val

5	full 64bit control	:: vmentry_msr_load_addr val
10	full 32bit control	:: vmentry_msr_load_count val

6	full 32bit control	:: primary_exit_ctl val

0	full 32bit control	:: pin_exec_ctrl val
1	full 32bit control	:: primary_proc_exec_ctrl val

1	full 16bit guest	:: guest_cs val
#14	full natural guest	:: guest_rsp val
#15	full natural guest 	:: guest_rip val
#16	full natural guest	:: guest_rflags val

#10	full natural host	:: host_rsp val

: ?VmReadWrite							\ ( field value ZF CF name -- )  {{{
	<<< -if -if _ >< _ else
		white count type bl emit yellow ." faulted, field " blue _ . norm cr
		8470cafe 600df00d4 .abort then
	else _ white count type bl emit red ." failed, field " blue _ . norm cr
		8470cafe badf00d4 .abort
	then ;
\ }}}
: try								
	\\ compile || compile cr compile yellow compile . compile blue compile . 	\ TODO if debug-vm
	' | compile | compile, >name [compile] literal 
	\\ compile | compile count compile type 					\ TODO
	compile ?VmReadWrite ; immediate

: VmRead	try vmread ;
: VmWrite	try vmwrite _ ;

: VmcsDump	\ {{{
       0 begin |
       {
               | vmread
               -if
                       -if
                               >< cr . .
                       else
                               _ _
                       then
              else
                       _ _ _
               then
       }
       1+ | 7000 < while  repeat _
; \ }}}

: VmExit? 							\ ( -- reason qualification )
	vmexit_reason VmRead 
	| VMEXIT_VMCALL <> if
		vmexit_qualification VmRead
		vmexit_gpa VmRead
		vmexit_gva VmRead
		vmexit_int_info VmRead
		vmexit_int_errcode VmRead
		vmexit_idt_info VmRead
		vmexit_idt_errcode VmRead
		vmexit_instr_len VmRead
		vmexit_instr_info VmRead
		guest_rip VmRead
		guest_cs VmRead
		1
	else
		_ 
		0
	then
;

: ?VmxRes							\ ( ZF CF name -- 0=sucesss | 1=fail ) {{{
	<<< -if -if _ else
		white count type bl emit yellow ." faulted, result "
		vminstruction_error VmRead blue . norm cr
		8470cafe 600df00d1 .abort then
	else _ red count type bl emit " failed" cr
		8470cafe badf00d1 .abort
	then ;
\ }}}
: try
	' | compile, >name [compile] literal compile ?VmxRes ; immediate

\\ Launch

\ VMCS
page vmcs
vmcs :: 'vmcs var

\ VM
page vm1
vm1 :: 'vm1 var

\ Host and guest stacks
:: sp	code |, r0 rsp mov, ret,

: h-sp	sp ffff_ffff_ffff_f000 and 1000 + 9 - ;
: g-sp	h-sp 10_0000 + ;

: status,	66 ` c7 ` 04 ` 25 ` 00 ` 80 ` 0b ` 00 ` ;
: status2,	66 ` c7 ` 04 ` 25 ` 00 ` 00 ` 00 ` 01 ` ;
:: .status	code 66 ` 89 ` 0c ` 25 ` 00 ` 80 ` 0b ` 00 ` _, ret,

: restart,	rtmp (restart) mov.i, rtmp push, ret, ;
: restart2,	rtmp (restart2) mov.i, rtmp push, ret, ;
: warm,		rtmp (warm) mov.i, rtmp call, ;
: warm2,	rtmp (warm2) mov.i, rtmp call, ;

0 :: 'h-begin var
0 :: 'h-vmexit var

0 :: 'g-begin var
0 :: 'u-begin var



: h-0 		'h-vmexit @ ?execute VmExit? if
			cr white ."  VM exit " 
			ired bl emit . [char] : emit . yellow bl emit . . . . . . blue . red .  white . yellow .
		then
		'h-begin @ ?execute cr ipurple ." HYPER " begin ipurple 10 emit (quit) again ;
: g-0		'g-begin @ ?execute cr iblue   ." SUPER " begin iblue   10 emit (quit) again ;
: u-0		'u-begin @ ?execute cr igreen  ."  USER " begin igreen  10 emit (quit) again ;

:: h-exit	code  	nop, nop,
			status, 48 ` 4f `  
			pusha,
			rtop ' h-0 mov.i,  warm, sti, restart, ret,
:: g-entry	code	nop, nop, 
			status, 47 ` 3f `  
			rtop ' g-0 mov.i,  warm, sti, restart, ret,
:: u-entry	code 
			nop, nop, 
			status, 55 ` 1f `
			rtop ' u-0 mov.i,  
			status, 56 ` 1f `
			warm2, 
			status, 57 ` 1f `
			restart2, ret, 

\ Host and guest MSRs {{{1

\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ AAA BBB to run under Linux 
:: host_msrs adr
: AAAAAAAAA
EFER 	| , msr ,
STAR 	| , msr ,
LSTAR 	| , msr ,
CSTAR  	| , msr ,
FMASK 	| , msr ,
FS_BASE | , msr ,
GS_BASE | , msr ,
KERNEL_GS_BASE | , msr ,
TSC_AUX | , msr ,
;
here host_msrs - 8/ 2/ :: #host_msrs val

:: guest_msrs adr
: BBBBBBBBBBB
EFER 	, 0 ,
STAR 	, 0 ,	
LSTAR 	, 0 ,
CSTAR 	, 0 ,
FMASK 	, 0 ,
FS_BASE	, 0 ,
GS_BASE	, 0 ,
KERNEL_GS_BASE , 0 ,
TSC_AUX	, 0 ,
;
here guest_msrs - 8/ 2/ :: #guest_msrs val

: VmWriteMsr
	host_msrs	vmexit_msr_load_addr  	VmWrite
	#host_msrs	vmexit_msr_load_count 	VmWrite

	guest_msrs	vmexit_msr_store_addr 	VmWrite
	#guest_msrs	vmexit_msr_store_count 	VmWrite

	guest_msrs	vmentry_msr_load_addr	VmWrite
	#guest_msrs	vmentry_msr_load_count	VmWrite
;
\ }}}

\ here 1000 aligned 4000 + :: ept val
EPT_ADDR	:: ept val
TSS_ADDR	:: tss val
KERNEL_PT_ADDR	:: kpt val 

\ EPTP
	0	
	6 0 bits set						\ Write-back memory type
	3 3 bits set						\ Page-walk length - 1 (4-level)
	\\ 6 bit set						\ Accessed and dirty flags
	ept set
	:: eptp val 
	0 , 							\ For INVEPT

0 :: kpt-pte var


: >pdpte	#page +	; 					\ ( pml4e -- pdpte )
: >pde		#page +	;					\ ( pdpte -- pde )
: >pte		#page 4 * + ;					\ ( pde -- pte )

: RWXuX	0 bit set 1 bit set 2 bit set ;				\ RXW access, \\ #10 bit execution in use mode allowed

: PtInit							\ ( pml4e -- )
	|{ 10_0000 0 fill }					

	| >pdpte |{ RWXuX >< ! }
								
	| >pde |{ RWXuX
	><
	4 for
		||{{ ! } #page + } cell+
	over
	_ _ }

	| >pte |{ RWXuX
	><
	200 4 * for						\ 2048 * 4KB pages = 8 MB
		||{{ ! }  #page + } cell+
	over
	_ _ }

	{ 0 RWXuX 6 3 bits set }				\ WB memory type
	800 10 * for
		>< | fff not and b8000 = if 
			7 3 bits reset 
		then >< 
		||{{ ! } #page + } cell+
	over
	_ _ 
;


: Pt4Ki2MiInit							\ ( pml4e -- )
	cr ." Memory fill..."
	|{ 10_0000 0 fill }					
	."  Done." cr					

	| >pdpte |{ RWXuX >< ! }
								
	| >pde |{ RWXuX
	><
	4 for
		||{{ ! } #page + } cell+
	over
	_ _ }

	{ 0 RWXuX 7 bit reset 6 bit reset 206_000 or }
	||{{ ! }} cell+ >< _  

	{ 0 RWXuX 7 bit set 6 bit reset 6 3 bits set 20_0000 + }
	200 4 * 1- for						\ 2048 * 4KB pages = 8 MB
		>< | fff not and KERNEL_PT_ADDR = if >< | kpt-pte ! >< then ><
		||{{ ! }  20_0000 + } cell+
	over
	 

	>< _
	{ 0 RWXuX 6 3 bits set  6 bit set }				\ WB memory type
	200 for
		\\ || >< cr yellow . .
		>< | fff not and b8000 = if 7 3 bits reset else 6 3 bits set then >< \ 7 3 bits reset | . 
		||{{ ! } #page + } cell+
	over
	_ _ 
	
;

: Pt2MiInit							\ ( pml4e -- )
	|{ 10_0000 0 fill }					

	| >pdpte |{ RWXuX >< ! }
								
	| >pde |{ RWXuX
	><
	4 for
		||{{ ! } #page + } cell+
	over
	_ _ }

	{ 0 RWXuX 7 bit set 6 bit reset }
	||{{ ! }} cell+ >< _

	{ 0 RWXuX 7 bit set 6 bit reset 6 3 bits set 20_0000 + }
	200 4 * for						\ 2048 * 4KB pages = 8 MB
		||{{ ! }  20_0000 + } cell+
	over
	_ _ 
	
;

\ EPT
: EptInit
	ept Pt4Ki2MiInit
;

\ Kernel (Supervisor) Pagetable
: KptInit
	kpt PtInit
;

\\ TSS

: TssInit
	tss 68 0 fill
	GUEST_STACK 10000 - tss 4 + !
	68 tss 66 + 2!
;


\\ VMX root operation
: VmxOn
	cr4 VMXE or cr4! 
	cr0 VM0S msr or VM0R msr and cr0!
	cr4 VM4S msr or VM4R msr and cr4!
	VBAS msr vmcs 4!

	'vmcs try vmxon

	2f48 .status	\ Host after VmxOn
;

: VmInit
	VBAS msr vm1 4!

	'vm1 try vmclear
	'vm1 try vmptrld

;
: VmCtrls
	0 
	VBAS msr #55 bit set? if 048d else 0481 then msr 2mask		\ Table 26-5: Pin-based Execution Conrols	
	0 full 32bit control VmWrite

	0 #31 bit set  1 bit set					\ Table 26-6: Primary Execution Controls
	VBAS msr #55 bit set? if 048e else 0482 then msr 2mask
	primary_proc_exec_ctrl VmWrite

	0 #31 bit reset	 1 bit set 048b msr 2mask			\ Table 26-7: Secondary Execution Controls
	#15 full 32bit control VmWrite 

	0  #9 bit set  #21 bit set					\ Table 26-14:	64-bit host, load EFER
	VBAS msr #55 bit set? if 048f else 0483 then msr 2mask
	6 full 32bit control VmWrite \ primary_exit_ctrl

	0  #9 bit set 	 						\ Table 26-17:	64-bit guest
	VBAS msr #55 bit set? if 0490 else 0484 then msr 2mask
	9 full 32bit control VmWrite \ primary_entry_ctrl

	0 0 bit set 1 bit set 2 bit set 3 bit set 4 bit set 5 bit set
	6 bit set 7 bit set 8 bit set #10 bit set #11 bit set  #13 bit set #14 bit set 
	#16 bit set #17 bit set  #19 bit set #20 bit set \ #18 bit set
	#20 bit set #28 bit set #29 bit set
	2 full 32bit control VmWrite \ Exception bitmap

	eptp #13 full 64bit control VmWrite \ EPTP
;

: VmHostState
	\ TODO #0 #1 #2 are defined in CORE. reconsider
	cr0	0 full natural host VmWrite
	cr3	1 full natural host VmWrite
	cr4	2 full natural host VmWrite

	h-sp 		#10 full natural host VmWrite
	['] h-exit	#11 full natural host VmWrite

	cs	1 full 16bit host VmWrite
	ds	0 full 16bit host VmWrite
	ds	2 full 16bit host VmWrite
	ds	3 full 16bit host VmWrite
	ds	4 full 16bit host VmWrite
	ds	5 full 16bit host VmWrite
	tr@ _	6 full 16bit host VmWrite
	
	FS_BASE msr 	3 full natural host VmWrite
	GS_BASE msr 	4 full natural host VmWrite
	1000	 	5 full natural host VmWrite

	gdt@ >< _	6 full natural host VmWrite
	idt@ >< _	7 full natural host VmWrite

	EFER msr	1 full 64bit host VmWrite
;

: VmGuestState
	cr0 	0 full natural guest VmWrite
	cr3	1 full natural guest VmWrite
	cr4	2 full natural guest VmWrite

	cs	1 full 16bit guest VmWrite
	ds	0 full 16bit guest VmWrite
	ds	2 full 16bit guest VmWrite
	ds	3 full 16bit guest VmWrite
	ds	4 full 16bit guest VmWrite
	ds	5 full 16bit guest VmWrite
	tr@ _	7 full 16bit guest VmWrite

	EFER msr _ 0d00	3 full 64bit guest VmWrite

	1000	 	#10 full natural guest VmWrite

	gdt@ >< _	#11 full natural guest VmWrite
	idt@ >< _ 	#12 full natural guest VmWrite
	
	-1		0 full 64bit guest VmWrite	\ vmcs link pointer

	00000002	guest_rflags VmWrite 	\ flags
	g-sp		guest_rsp VmWrite
	cs		guest_cs VmWrite
	['] g-entry 	guest_rip VmWrite

	-1	0 full 32bit guest VmWrite		\ segment limits
	-1	1 full 32bit guest VmWrite
	-1	2 full 32bit guest VmWrite
	-1	3 full 32bit guest VmWrite
	-1	4 full 32bit guest VmWrite
	-1	5 full 32bit guest VmWrite

	67	7 full 32bit guest VmWrite
	ffff	8 full 32bit guest VmWrite
	3ff	9 full 32bit guest VmWrite

							\ Table B-10. Table 26-2. Format of Access Rights
	0 0 bit set 1 bit set 3 bit set 4 bit set 7 bit set #13 bit set #15 bit set
		#11 full 32bit guest VmWrite

	0 0 bit set 1 bit set 4 bit set 7 bit set #14 bit set #15 bit set
		| #10 full 32bit guest VmWrite
		| #12 full 32bit guest VmWrite
		| #13 full 32bit guest VmWrite
		| #14 full 32bit guest VmWrite
		| #15 full 32bit guest VmWrite _


	0 0 bit set 1 bit set 3 bit set 7 bit set
		#17 full 32bit guest VmWrite

	0 1 bit set 7 bit set
		#16 full 32bit guest VmWrite
;
: VmLaunch
	['] g-0 warm

	'vm1 try vmlaunch
;
: VmResumeRestart
	guest_cs VmRead
	| GUEST_CS =		if _ ." G1" GUEST_STACK ['] g-entry ['] g-0 else
	| SUPERVISOR_CS =	if _ ." G2" GUEST_STACK ['] g-entry ['] g-0 else
	| USER_CS =		if _ ." U " USER_STACK  ['] u-entry ['] u-0 else
		abort" Unknown guest CS " . cr
	then then then 

	warm
	guest_rip VmWrite
	guest_rsp VmWrite

	'vm1 vmresume
	." ========= VMRESUME FAILED ==============="

	['] h-0 warm						\ On failure restore host console?
;
: VmResumeCurrent
	1f75 .status
	'vm1 vmresumea
	." ========= VMRESUMEA FAILED ==============="
;
: InvEpt
	['] eptp try invept
;


: VmRun
	VmxOn VmInit VmCtrls
	VmHostState 
	VmGuestState

	\ VmLaunch
;

\\ Guest operation

:: u-gdt	adr
	0 ,	\ 00 Empty
	0 ,	\ 08 Empty
	0  	\ 10 Kernel CS
	0  7 bit set  0 5 bits set  4 bit set 3 bit set  1 bit set  #40 bits set	\ Access: P DPL=0 ~S E R
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	\ 0 ,
	0 	\ 18 Kernel DS
	0  7 bit set  0 5 bits set  4 bit set  1 bit set  #40 bits set			\ Access: P DPL=0 ~S RW
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	0  	\ 20 Kernel CS
	0  7 bit set  0 5 bits set  4 bit set  3 bit set  1 bit set  #40 bits set	\ Access: P DPL=0 ~S E R
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	0 	\ 28 Kernel DS
	0  7 bit set  0 5 bits set  4 bit set  1 bit set  #40 bits set			\ Access: P DPL=0 ~S RW
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	0	\ 30 User CS
	0  7 bit set  3 5 bits set  4 bit set  3 bit set  1 bit set 0 bit set #40 bits set	\ Access: P DPL=3 ~S E R
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	0	\ 38 User DS
	0  7 bit set  3 5 bits set  4 bit set  1 bit set  #40 bits set			\ Access: P DPL=3 ~S RW
	0  3 bit set  1 bit set  #52 bits set						\ Flags:  G L
	ffff set f #48 bits set								\ Limit
	,
	0	\ 40 TSS
	0  7 bit set 0 5 bits set 4 bit reset  9 0 bits set  #40 bits set		\ Access: P DPL=0 S 64-bit available TSS

	90000 #16 bits set								\ Base 90_000
	67 set										\ Limit



	\ 0000 89 001000 00ff	\ 40 TSS descriptor
	,
	0000000000000000	\ This line is needed!
	,

here u-gdt - 1-
:: u-gdtr	adr	2, u-gdt ,

: .gdt		cell+ cell+ cell+ cell+ | @ . cell+ | @ . cell+ | @ . cell+ | @ . cell+ @ . ;
: .u-gdt	u-gdt .gdt ;

20 		:: KERNEL_CS val
28 		:: KERNEL_DS val
30 3 0 bits set	:: USER_CS val
38 3 0 bits set	:: USER_DS val
40		:: KERNEL_TSS val

: lgdt,		0f ` 01 ` 11 ` ;
: ltr,		0f ` 00 ` d9 ` ;
: load-gdt,	cli, lgdt, 
		rtop KERNEL_CS mov.i, rtop push,
		call0, 
		rtop pop, rtop 08 add.i, rtop push, \ point to ret,
		retfq, sti, ret, ;

: UsrLgdt	u-gdtr asm( load-gdt, )asm ;

:: s-ret	code retfq,

:: u-enter	code
		|, 
		cli,
		rtop USER_DS mov.i, rtop push,
		ds!, es!, fs!, gs!,
		rtop KERNEL_TSS mov.i, ltr,
		rtop USER_STACK mov.i, rtop push,
		rtop 3202 mov.i, rtop push, \ TF on
		rtop USER_CS mov.i, rtop push,
		rtop ' u-entry mov.i, rtop push,
		iretq,

\\ Initialization
		
\ Guest
0 :: g-init? var
: GuestInit
	iblue ." g"	
	g-init? @ if exit then 1 g-init? !

	cr purple ." Guest initialization..." white
	
	UsrLgdt
	KptInit kpt cr3!
;
latest 'g-begin !

\\ EPT-based mitigation

: Ept@	kpt-pte @ @ ;
: EptW+	kpt-pte @ |{ @   1 bit set   } ! ;
: EptW-	kpt-pte @ |{ @   1 bit reset } ! ;
: Mtf+	primary_proc_exec_ctrl |{ VmRead #27 bit set   } VmWrite ;
: Mtf-	primary_proc_exec_ctrl |{ VmRead #27 bit reset } VmWrite ;

: within <<< >| <= { >= } and ;	
	

: HostVmExitHandler
	cs 33 = if
		cr cr red ." ******************************************************************************* "
	then

	vmexit_gpa VmRead KERNEL_PT_ADDR | 200_000 + 1- within if
		guest_rip VmRead
		vmexit_reason VmRead 
		| VMEXIT_EPT = if _ 
			vmexit_gpa VmRead KERNEL_PT_ADDR <> if
				\ 10 1 cursor
				cr ipurple ." E " . ." g-rsp " guest_rsp VmRead . ." h-rsp " host_rsp VmRead . ." rsp " sp . red vmexit_gpa VmRead .
			else
				EptW+ Mtf+ VmResumeCurrent 
			then
		else
		| VMEXIT_MTF = if _ 
			\ ipurple ." M " . norm .S
			EptW- Mtf- VmResumeCurrent else
		_
		then then 
	then

	vmexit_reason VmRead 
	| VMEXIT_EXC = if _
		vmexit_int_info VmRead | . 0ff and 01 = if
			VmResumeCurrent
		else
		_
		then
	else
	_
	then 
;
latest 'h-vmexit !


\\ Logo, UI, Run

: LOGO cr 1 emit 5f emit ."  HYPER OPERATION " cr ;

: ll VmLaunch ;
: uu UsrLgdt ;
: rr VmResumeRestart ;
: rc VmResumeCurrent ;
: qq u-enter ;
: xx vmcall ;
: ww EptW- ;

EptInit
TssInit
VmRun

LOGO

