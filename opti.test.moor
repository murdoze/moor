\\
\\ Optimizer tests
\\

\\ TODO
\ uemit3 -- wrong result
\ uemit1 -- wrong result and crash
\ if3, if4 -- make different paths and compare optimized and non-optimized code

: optimize!
	( :#params :xt )
	here | ." CODE at " .
	{
	regalloc-init :#params | if for ?^ over else _ then 
	:#params :xt optimize
	}
	(code) interpretation :xt does
	return
;


: fib		| if 0 1 >>> for >| + >< over _ then ;
: nup		>r _ r> ;
: swap2		0 <<< <<< nup ;
: lswap		( :c :d ) :c :d :c! :d! :c :d return ;
: -lswap	( :c :d ) :c :d :c! :d! :d :c return ;
: onep		| 1+ 1+ 1+ >< - ;
: cset		1 3333 c! ;
: if0		0 if then ;
: if1		1 2 - if 0 else 1 then 30 + emit cr ;
: if2		1 2 < if 0 else 1 then 30 + emit cr ;
: if3		1 if 2 else 3 if 4 else 5 then then _ ;
: iflong1	0 if 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
		else
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
		then ;
: for1		3 for | uemit over _ cr ;
: for2		( :c ) 1 for :c emit over return ;
: fill		<<< for >|>| c! 1+ over _ _ ;
: fill2		( :a :n :c ) :a :n for | :c >< c! 1+ over _ return ;
: fill3		( :a :n :c ) :n for :c emit over return ;
: fill4		( :a :n :c ) :n if :c emit then return ;
: emit1		41 42 43 emit emit emit cr ;
: sar1		200 3 sar emit cr ;
: sar2		1 200 | { 3 sar } + 201 - emit cr ;
: andor1	1 3 and 2 or 40 + emit ;
: orand1	1 3 or 2 and 40 + emit ;
: pp1		1 3 + 2 + 40 + emit ;
: less1		| 35 < if 1+ else 1- then emit cr ;
: uemit1	4351 uemit cr ;
: u2emit1	7 9 u2emit cr ;
: u2emit2	407 6lsb u2emit cr ;
: uemit3
  | 80 < if 41 else
  | 800 < if 42 else
  | 10000 < if 43 else
  | 110000 < if 44 else
  45 then then then then emit cr ;
: if4 1		
  | if 1 else 
  | if 4 else 
  5 then then 30 + emit _ ;


: opti-fib	1 ['] fib	optimize! ;
: opti-nup	2 ['] nup	optimize! ;
: opti-swap2	2 ['] swap2	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti--lswap	2 ['] -lswap	optimize! ;
: opti-onep	1 ['] onep	optimize! ;
: opti-cset	0 ['] cset	optimize! ;
: opti-fill	3 ['] fill	optimize! ;
: opti-emit1	0 ['] emit1	optimize! ;
: opti-sar1	0 ['] sar1	optimize! ;
: opti-sar2	0 ['] sar2	optimize! ;
: opti-andor1	0 ['] andor1	optimize! ;
: opti-orand1	0 ['] orand1	optimize! ;
: opti-pp1	0 ['] pp1	optimize! ;
: opti-less1	1 ['] less1	optimize! ;
: opti-uemit1	0 ['] uemit1	optimize! ;
: opti-u2emit1	0 ['] u2emit1	optimize! ;
: opti-u2emit2	0 ['] u2emit2	optimize! ;
: opti-uemit3	1 ['] uemit3	optimize! ;

: opti-if0	0 ['] if0	optimize! ;
: opti-if1	0 ['] if1	optimize! ;
: opti-if2	0 ['] if2	optimize! ;
: opti-if3	0 ['] if3	optimize! ;
: opti-if4	0 ['] if4	optimize! ;
: opti-iflong1	0 ['] iflong1	optimize! ;
: opti-for1	1 ['] for1	optimize! ;
: opti-for2	1 ['] for2	optimize! ;
: opti-fill2	3 ['] fill2	optimize! ;
: opti-fill3	3 ['] fill3	optimize! ;
: opti-fill4	3 ['] fill4	optimize! ;

: type-fill2	~Adr ~Number ~Number ['] fill2 typecheck ;

maze
: opti-MAZE	0 ['] MAZE	optimize! ;


:: zzz adr 100 allot
: qqq zzz 10 31 fill2 ;




