\\
\\ Optimizer tests
\\

: optimize!
	( :#params :xt )
	here | ." CODE at " .
	{
	regalloc-init :#params | if for ?^ over else _ then 
	:#params :xt optimize
	}
	(code) interpretation :xt does
	return
;


: fib		| if 0 1 >>> for >| + >< over _ then ;
: nup		>r _ r> ;
: swap2		0 <<< <<< nup ;
: lswap		( :c :d ) :c :d :c! :d! :c :d return ;
: -lswap	( :c :d ) :c :d :c! :d! :d :c return ;
: onep		| 1+ 1+ 1+ >< - ;
: cset		1 3333 c! ;
: if0		0 if then ;
: if1		1 2 - if 0 else 1 then 30 + emit cr ;
: if2		1 2 < if 0 else 1 then 30 + emit cr ;
: if3		
  | 1 and if 41 else 
  | 2 and if 44 else 
  45 then then emit cr _ ;
: if4
  | 1 < if 41 else 
  | 2 < if 42 else 
  43 then then emit cr _ ;
: iflong1	0 if 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
		else
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
		then ;
: for1		3 for | uemit cr over _ cr ;
: for11		3 for | emit over _ cr ;
: for2		( :c ) 1 for :c emit over return ;
: fill0		<<< for >|>| c! 1+ over _ _ ;
: fill2		( :a :n :c ) :a :n for | :c >< c! 1+ over _ return ;
: fill3		( :a :n :c ) :n for :c emit over return ;
: fill4		( :a :n :c ) :n if :c emit then return ;
: emit1		41 42 43 emit emit emit cr ;

: sar0		70 | 1 sar emit emit ;
: sar01		1 70 | >>> sar emit emit ;
: sar1		200 3 sar emit cr ;
: sar2		1 200 | { 3 sar } + 201 - emit cr ;

: andor1	1 3 and 2 or 40 + emit ;
: orand1	1 3 or 2 and 40 + emit ;
: pp1		1 3 + 2 + 40 + emit ;
: less1		| 35 < if 1+ else 1- then emit cr ;
: uemit1	4351 uemit cr ;
: u2emit1	7 9 u2emit cr ;
: u2emit2	407 6lsb u2emit cr ;
: uemit3
  | 80 < if 41 else
  | 800 < if 42 else
  | 10000 < if 43 else
  | 110000 < if 44 else
  45 then then then then emit _ cr ;

: uemit4
  | 80 < if _ 41 emit  else
  | 800 < if _ 42 43 emit emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit else
  | 10000 < if _ 43 44 45 emit emit emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit else
  | 110000 < if _ 44 45 46 47 emit emit emit emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit else
  _ 45 emit then then then then cr ;

: 6lsb0 | 3f and >< 2/ 2/ 2/ 2/ 2/ 2/ ;
: 6lsb1 | >< 2/ ;
: ++ 1+ 1+ ;
: uemit0
  | 80 < if _ 41 emit else
  | 800 < if _ 42 emit else
  | 10000 < if _ 43 emit else
  | 110000 < if | >< ++ emit emit else
  _ 30 emit then 31 emit then 32 emit then 33 emit then cr ;

\\ TODO: branch offsets wrong !!!
: if5	| if ++ then     | if ++ then ;
: if6	| if 1+ 1+ then  | if 1+ 1+ then ;
: if7   | if if5 else 41 + emit cr then noop ;
: if8   | if | if ++ then 30 + emit cr noop else 30 + emit cr then noop ;

: if90  | if 5 else 6 then ;
: if9   | if if90 else 9 then 30 + emit ;

: noop1 ++ ;
: noop2 noop ;
: noop3 ;

: .str1	noop ." STRING111" cr ;
:: 'str1 adr 07 c, 31 c, 32 c, 33 c, 41 c, 42 c, 43 c, 0a c,
: type1	[ 'str1 literal ] 1+ 7 type ;
: type2	[ 'str1 literal ] count type ;

:: (var) 42 var
: var0	(var) ;
: var1	(var) @ emit cr ;

:: (val) 42 val
: val0	(val) emit ;

: opti-fib	1 ['] fib	optimize! ;
: opti-nup	2 ['] nup	optimize! ;
: opti-swap2	2 ['] swap2	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti--lswap	2 ['] -lswap	optimize! ;
: opti-onep	1 ['] onep	optimize! ;
: opti-cset	0 ['] cset	optimize! ;
: opti-fill	3 ['] fill	optimize! ;
: opti-emit1	0 ['] emit1	optimize! ;

: opti-sar0	0 ['] sar0	optimize! ;
: opti-sar01	0 ['] sar01	optimize! ;
: opti-sar1	0 ['] sar1	optimize! ;
: opti-sar2	0 ['] sar2	optimize! ;

: opti-andor1	0 ['] andor1	optimize! ;
: opti-orand1	0 ['] orand1	optimize! ;
: opti-pp1	0 ['] pp1	optimize! ;
: opti-less1	1 ['] less1	optimize! ;
: opti-uemit1	0 ['] uemit1	optimize! ;
: opti-u2emit1	0 ['] u2emit1	optimize! ;
: opti-u2emit2	0 ['] u2emit2	optimize! ;
: opti-uemit3	1 ['] uemit3	optimize! ;
: opti-uemit4	1 ['] uemit4	optimize! ;
: opti-uemit0	1 ['] uemit0	optimize! ;

: opti-if0	0 ['] if0	optimize! ;
: opti-if1	0 ['] if1	optimize! ;
: opti-if2	0 ['] if2	optimize! ;
: opti-if3	1 ['] if3	optimize! ;
: opti-if4	1 ['] if4	optimize! ;
: opti-if5	1 ['] if5	optimize! ;
: opti-if6	1 ['] if6	optimize! ;
: opti-if7	1 ['] if7	optimize! ;
: opti-if8	1 ['] if8	optimize! ;
: opti-if9	1 ['] if9	optimize! ;
: opti-noop1	1 ['] noop1	optimize! ;
: opti-noop2	1 ['] noop2	optimize! ;
: opti-noop3	1 ['] noop3	optimize! ;

: opti-iflong1	0 ['] iflong1	optimize! ;
: opti-for1	1 ['] for1	optimize! ;
: opti-for11	1 ['] for11	optimize! ;
: opti-for2	1 ['] for2	optimize! ;
: opti-fill2	3 ['] fill2	optimize! ;
: opti-fill3	3 ['] fill3	optimize! ;
: opti-fill4	3 ['] fill4	optimize! ;

: opti-baremetal? 0 ['] baremetal? optimize! ;

: opti-.str1	0 ['] .str1	optimize! ;
: opti-type1	0 ['] type1	optimize! ;
: opti-type2	0 ['] type2	optimize! ;

: opti-var0	0 ['] var0	optimize! ;
: opti-var1	0 ['] var1	optimize! ;
: opti-val0	0 ['] val0	optimize! ;

: type-fill2	~Adr ~Number ~Number ['] fill2 typecheck ;
: type-if3	~Number ['] if3 typecheck ;
: type-if4	~Number ['] if4 typecheck ;

maze
: opti-MAZE	0 ['] MAZE	optimize! ;
: opti-.M	0 ['] .M	optimize! ;


:: zzz adr 100 allot
: qqq zzz 10 31 fill2 ;




