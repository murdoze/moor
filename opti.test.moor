\\
\\ Optimizer tests
\\


: optimize!
	( :#params :xt )
	here | ." CODE at " .
	{
	regalloc-init :#params | if for ?^ over else _ then 
	:#params :xt optimize
	}
	(code) interpretation :xt does
	return
;


: fib		| if 0 1 >>> for >| + >< over _ then ;
: nup		>r _ r> ;
: swap2		0 <<< <<< nup ;
: lswap		( :c :d ) :c :d :c! :d! :c :d return ;
: -lswap	( :c :d ) :c :d :c! :d! :d :c return ;
: onep		| 1+ 1+ 1+ >< - ;
: cset		1 3333 c! ;
: if1		1 2 - if 0 else 1 then ;
: if2		1 2 < if 0 else 1 then ;
: iflong1	0 if 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
			41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 41 emit 
		else
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
			42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 42 emit 
		then ;
: for1		3 for | uemit over _ cr ;
: for2		( :c ) 1 for :c emit over return ;
: fill		<<< for >|>| c! 1+ over _ _ ;
: fill2		( :a :n :c ) :a :n for | :c >< c! 1+ over _ return ;
: fill3		( :a :n :c ) :n for :c emit over return ;
: fill4		( :a :n :c ) :n if :c emit then return ;
: emit1		41 42 43 emit emit emit cr ;
: sar1		200 3 sar emit cr ;
: andor1	1 3 and 2 or 40 + emit ;
: orand1	1 3 or 2 and 40 + emit ;
: pp1		1 3 + 2 + 40 + emit ;


: opti-fib	1 ['] fib	optimize! ;
: opti-nup	2 ['] nup	optimize! ;
: opti-swap2	2 ['] swap2	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti-lswap	2 ['] lswap	optimize! ;
: opti--lswap	2 ['] -lswap	optimize! ;
: opti-onep	1 ['] onep	optimize! ;
: opti-cset	0 ['] cset	optimize! ;
: opti-fill	3 ['] fill	optimize! ;
: opti-emit1	0 ['] emit1	optimize! ;
: opti-sar1	0 ['] sar1	optimize! ;
: opti-andor1	0 ['] andor1	optimize! ;
: opti-orand1	0 ['] orand1	optimize! ;
: opti-pp1	0 ['] pp1	optimize! ;

: opti-if1	0 ['] if1	optimize! ;
: opti-if2	0 ['] if2	optimize! ;
: opti-iflong1	0 ['] iflong1	optimize! ;
: opti-for1	1 ['] for1	optimize! ;
: opti-for2	1 ['] for2	optimize! ;
: opti-fill2	3 ['] fill2	optimize! ;
: opti-fill3	3 ['] fill3	optimize! ;
: opti-fill4	3 ['] fill4	optimize! ;

: type-fill2	~Adr ~Number ~Number ['] fill2 typecheck ;

maze
: opti-MAZE	0 ['] MAZE	optimize! ;


:: zzz adr 100 allot
: qqq zzz 10 31 fill2 ;




