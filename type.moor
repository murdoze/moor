								\\ TODO
\ 1) <DOES for STACK so that stacks have stack type
\
								\\ Xtlit TODO: consider moving to CORE
: xtlit		@skip ;
: xtliteral	compile xtlit , ; immediate
: [']      	' [compile] xtliteral ; immediate

								\\ Static type check
:: typechecking		:state

:: latest-typecheck	latest var
:: current-typecheck	latest var

: typechecking!!	typechecking state!! ;

interpretation ' (beginning) 	behavior  typechecking ' (beginning)    does
interpretation ' dummy	        behavior  typechecking ' exit           does
interpretation ' exit 		behavior  typechecking ' (ending)       does
interpretation ' interpreting!  behavior  typechecking ' interpreting!  does
interpretation ' (interpreting) behavior  typechecking ' (interpreting) does
interpretation ' typechecking!! behavior  typechecking ' typechecking!! does

: Texit		compile typechecking!! compile (ending) ; immediate

								\\ Type registration
:: TMASK	88_00_00_00 val
:: XTMASK	01 val
:: -XTMASK	-2 val

: Type		TMASK or , does> XTMASK or ;

:: ~Any		00_00_00 Type

:: ~Number	00_00_01 Type
:: ~#Str	00_01_01 Type					\ Counted string length
:: ~Integer	00_02_01 Type
:: ~Bool	01_02_01 Type

:: ~Adr		00_00_02 Type
:: ~'#Str	00_01_02 Type					\ Pointer to a counted string
:: ~Xt		00_02_02 Type

:: ~Str		00_00_03 Type					\ String slice


								\\ Type checking definitions
:: in-typecheck-def	0 var
: T:								\ ( "<name>" -- )	Defines static typecheck behavior for a word
	in-typecheck-def @ if abort" Typecheck definition not finished" then
	here exec typechecking ' | latest-typecheck ! does
        compile interpreting!
	compile r> compile | compile >r compile cell- compile current-typecheck compile !
	] 
	1 in-typecheck-def !
;
: ;T	[compile] Texit [compile] [ 
	0 in-typecheck-def !
; immediate

: typecheck-inside
	typechecking interpretation >>> behavior execcfa interpreting! ;
: ...;T								\ 			Continue typechecking of the inside of the definition
	latest-typecheck @ [compile] literal compile typecheck-inside
	[compile] ;T ; immediate

: typecheck							\ ( xt -- )		Run XT in static type checking mode
	|{
	typechecking state!
	execute
	interpreting! interpretation state! 
	} \ xt
	_
;

: (:)      : ;							\ 			Redefine : to enable typechecking state TODO: ANALYZE
: :        (:) interpretation latest behavior typechecking latest does ;

: ..name .name ;

: ?depth
	>< || < if >>>
		blue ..name bl emit
		yellow ." depth: expected " blue . bs yellow ." , got " blue . norm
		." at " current-typecheck @ . cr
		unwind
		abort 
	then _ _ _ ;
: ?D
	compile depth compile 1- latest-typecheck @ [compile] literal compile <<< compile ?depth ; immediate

: T>xt	-2 and 
	| | 0f and if red ." Xt expected, received " norm . ." at " current-typecheck @ . cr unwind abort then _
	| | -1000 and -if red ." Xt expected, received " norm . ." at " current-typecheck @ . cr unwind abort then _
;
: T~
	|| = if _ _ 1 exit then
	| XTMASK and if else _ _ 0 exit then T>xt  @ ><
	| XTMASK and if else _ _ 0 exit then T>xt  @
	>< || and >| = if _ _ 1 exit then
	>< || and >| = if _ _ 1 exit then
	_ _ 0
; 
: .type	T>xt ..name ;

: ?typecheck
	<<< || T~ -if >>>
		blue .type bl emit
		yellow ." typecheck error:"
		blue ."  expected " yellow .type
		blue ." , received " yellow .type norm cr abort
	then _ _ _ ;

: assert-type							\ ( t1 t2 -- | ABORT)
	latest-typecheck @ [compile] literal
	compile ?typecheck ; immediate
: ?T	[compile] assert-type ; immediate
								\\ Control structure stack
:: tcs-stack	100 stack
: >>tcs	depth tcs-stack #|>>s _ ;
: tcs>>	tcs-stack s#>> _ ;

\\ Typecheck implementation

T: dummy	abort ;T

T: (does)	;T
T: does		;T
T: latest	~Xt ;T

T: lit		skip ~Number ;T
T: xtlit	skip ~Xt ;T
T: >name	1 ?D ~Xt ?T ~'#Str ;T
T: baremetal?	~Bool ;T
T: abort	;T

T: bl		~Number ;T
T: emit		1 ?D ~Number ?T ;T
T: .		1 ?D ~Number ?T ;T
T: (")		(")-skip ~'#Str ;T
T: count 	1 ?D ~'#Str ?T ~Str ~Number ;T
T: type 	2 ?D ~Number ?T ~Str ?T ;T

T: key		~Number ;T

T: (does>)	1 ?D ~Number ?T ;T	\\ TODO ~Xt xtlit/xtliteral ?
T: xexit	;T

T: ?branch	1 ?D ~Any ?T skip ;T
T: branch	skip ;T

T: (if-post)	>>tcs ;T
T: (else-post)	depth #_ tcs>> ;T

T: (while-post)	>>tcs ;T
T: (repeat-post) depth #_ tcs>> ;T

T: (for)	1 ?D ~Number ?T ;T
T: I		~Number ;T
T: (over)	skip ;T
T: (over-post)	;T

T: allot	1 ?D ~Number ?T ;T

T: ,		1 ?D _ ;T
T: |		1 ?D | ;T
T: _		1 ?D _ ;T
T: ><		2 ?D >< ;T
T: >|		2 ?D >| ;T
T: >|>|		2 ?D >|>| ;T
T: >>>		2 ?D >>> ;T


T: =		2 ?D ?T ~Bool ;T

T: shl		2 ?D ~Number ?T ~Number ?T ~Number ;T	\\ TODO: ~Adr also can be shifted by number.
T: sar		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: and		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: or		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: xor		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: not		1 ?D ~Number ?T ~Number ;T

T: @		1 ?D ~Adr ?T ~Number ;T
T: !		2 ?D ~Adr ?T _ ;T
T: 1+		1 ?D ;T
T: 1-		1 ?D ;T
T: 2/		1 ?D ~Number ?T ~Number ;T

T: +		2 ?D 
		| ~Number T~ if >< | ~Number T~ if _ _ ~Number Texit then | ~Adr T~ if _ _ ~Adr Texit then else 
		| ~Adr    T~ if >< | ~Number T~ if _ _ ~Adr Texit then then
		then yellow ." '+' accepts two numbers, number and address or address and number, got " 
		blue .type yellow ."  and " blue .type norm cr abort ;T
T: -		2 ?D 
		| ~Number T~ if >< | ~Number T~ if _ _ ~Number Texit then else 
		| ~Adr    T~ if >< | ~Number T~ if _ _ ~Adr Texit then then
		then yellow ." '-' accepts numbers or address and number, got " 
		blue .type yellow ."  and " blue .type norm cr abort ;T
T: *		2 ?D ~Number ?T ~Number ?T ~Number ;T

: 2~Number~Adr
		2 ?D
		| ~Number T~ if >< | ~Number T~ if _ _ 1 exit then then
		| ~Adr    T~ if >< | ~Adr    T~ if _ _ 1 exit then then
		_ _ 0
;
: .2~Number~Adr-expected
		yellow ." accepts two numbers or two addresses, got "
		blue .type yellow ."  and " blue .type norm cr abort
;
T: >		2~Number~Adr if ~Bool else blue ." '>' "  .2~Number~Adr-expected then ;T
T: <		2~Number~Adr if ~Bool else blue ." '<' "  .2~Number~Adr-expected then ;T
T: <>		2~Number~Adr if ~Bool else blue ." '<>' " .2~Number~Adr-expected then ;T

T: randseed	~Adr ;T

\ Return stack
:: rstack-types	10 stack

T: (>r)		1 ?D rstack-types >s ;T
T: (r>)		rstack-types s> ;T

\ Locals
T: locals(	;T
T: -locals-	;T
T: )locals	;T

T: #l@		@skip rstack-types |{ #s >< - 1- } s#@ ;T
T: #l!		@skip rstack-types |{ #s >< - 1- } s#! ;T

\\ Typechecking for DOES>

: typecheck-does<	typechecking does< ; immediate
: >typecheck-does	compile typechecking!! >does ; immediate

\\ Stack

' stack : stack [ compile, ] typecheck-does< _ ['] stack >typecheck-does ;

: ?Tstack	1 ?D ['] stack ;
T: empty	?Tstack ?T ~Adr ...;T
T: stack@	?Tstack ?T ~Adr ...;T
T: .stack	?Tstack ?T ~Adr ...;T
T: >s		?Tstack ?T ~Adr ...;T
T: s>		?Tstack ?T ~Adr ...;T


: test-stack-withsize	10 stack ;

:: stack1 10 stack
: test->s-stack1	stack1 >s ;

: test-stack-type

 	TEST" üìù Stack no size"			['] stack	 	typecheck ?FAILED
	TEST" üìù Stack with size 1"		10 ['] stack		typecheck ?FAILED
	TEST" üìù Stack with size 2"		['] test-stack-withsize typecheck ?SUCCEEDED
	TEST" üìù Stack size non-number dummy"	['] dummy ['] stack	typecheck ?FAILED
	TEST" üìù Stack size non-number ~Adr"	~Adr ['] stack		typecheck ?FAILED

	TEST" üìù >S any with stack"		~Any ['] stack ['] >s	typecheck ?SUCCEEDED
	TEST" üìù >S with stack no value"	['] stack ['] >s	typecheck ?FAILED
	TEST" üìù >S any with non-stack"		~Any ~Number ['] >s	typecheck ?FAILED

	TEST" üìù >S any with stack1"		~Any ['] test->s-stack1	typecheck ?SUCCEEDED
;

\\ Control structures

: cs1	\ ( n1 n2 -- )
	| _ 1 and | _ if
		| 2/ 1 and if
			1-
		else
			1+ 
		then
		30 + emit

	else
		|
	 	3 and 3 = if
			43
		else
			44
		then
		>< _ emit
	then
	cr
;

: cs2	if 1+ else 2+ then emit ;
: cs3	if 41 else if 42 else 43 then then emit cr ;


: test-cs-type
	TEST" üìù IF1 non-types"			0 4 ['] cs1 		typecheck ?FAILED
	TEST" üìù IF1 non-type and type"		0 ~Number ['] cs1 	typecheck ?FAILED
	TEST" üìù IF1 numbers"			~Number ~Number	['] cs1 typecheck ?SUCCEEDED

	TEST" üìù IF2 any"			~Any ['] cs2 		typecheck ?FAILED
	TEST" üìù IF2 any any"			~Any ~Any ['] cs2 	typecheck ?SUCCEEDED

	TEST" üìù IF3 numbers"			~Number ~Number	['] cs3	typecheck ?SUCCEEDED
;

\ Variables

' var : var [ compile, ] typecheck-does< _ ~Adr >typecheck-does ;
' val : val [ compile, ] typecheck-does< _ ~Any >typecheck-does ;
' adr : adr [ compile, ] typecheck-does< _ ~Adr >typecheck-does ;

:: test-var1	0 var
:: test-val1	0 var
:: test-adr1	0 var

: test-var-type
	TEST" üìù Var1"	['] test-var1 typecheck ?SUCCEEDED 
	TEST" üìù Val1"	['] test-val1 typecheck ?SUCCEEDED
	TEST" üìù Adr1"	['] test-adr1 typecheck ?SUCCEEDED 
;

: t-emit1 31 emit ;
: t-emit2 emit ;

: type-emit1 ['] t-emit1 typecheck ;
: type-emit2 ~Number ['] t-emit2 typecheck ;

