								\\ TODO
\ 1) <DOES for STACK so that stacks have stack type
\ 3) Control structures: save-restore stack, φ-junctions
\
								\\ Static type check
:: typechecking		:state

:: latest-typecheck	latest var

:: typechecking!!	code rstate typechecking  mov.i, ret,	\ ( -- )	Sets state to typechecking without address interpreter involvement

: Texit		compile typechecking!! compile exit ; immediate

interpretation ' exit 	        behavior typechecking ' exit           does
interpretation ' interpreting!  behavior typechecking ' interpreting!  does
interpretation ' (interpreting) behavior typechecking ' (interpreting) does
interpretation ' typechecking!!  behavior typechecking ' typechecking!!  does

								\\ Type registration
:: TMASK	88_00_00_00 val
:: XTMASK	01 val
:: -XTMASK	-2 val

: Type		TMASK or , does> XTMASK or ;

:: ~Any		00_00_00 Type

:: ~Number	00_00_01 Type
:: ~#Str	00_01_01 Type					\ Counted string length
:: ~Integer	00_02_01 Type

:: ~Adr		00_00_02 Type
:: ~'#Str	00_01_02 Type					\ Pointer to a counted string
:: ~Xt		00_02_02 Type

:: ~Str		00_00_03 Type					\ String slice


								\\ Type checking definitions
: T:								\ ( "<name>" -- )	Defines static typecheck behavior for a word
	here exec typechecking ' | latest-typecheck ! does
        compile interpreting!
	] 
;
: ;T	[compile] Texit [compile] [ ; immediate

: typecheck-inside 
	typechecking 
	interpretation latest-typecheck @ behavior 
	execcfa ;
: ;T...	
	compile typecheck-inside

	[compile] ;T ; immediate	\ 			Continue typechecking of the inside of the definition

: typecheck							\ ( xt -- )		Run XT in static type checking mode
	|{
	typechecking state!
	execute
	interpreting! interpretation state! 
	} \ xt
;

: (:)      : ;							\ 			Redefine : to enable typechecking state TODO: ANALYZE
: :        (:) interpretation latest behavior typechecking latest does ;

: ?depth
	>< || < if >>>
		blue .name bl emit
		yellow ." depth: expected " blue . bs yellow ." , got " blue . norm cr abort 
	then _ _ _ ;
: ?D
	compile depth compile 1- latest-typecheck @ [compile] literal compile <<< compile ?depth ; immediate

: T>xt	-2 and ;
: T~
	|| = if _ _ 1 exit then
	| XTMASK and if else _ _ 0 exit then T>xt @ ><
	| XTMASK and if else _ _ 0 exit then T>xt @
	>< || and >| = if _ _ 1 exit then
	>< || and >| = if _ _ 1 exit then
	_ _ 0
; 
: .type	T>xt .name ;

: ?typecheck
	<<< || T~ -if >>>
		blue .type bl emit
		yellow ." typecheck error:"
		blue ."  expected " yellow .type
		blue ." , received " yellow .type norm cr abort
	then _ _ _ ;

: assert-type							\ ( t1 t2 -- | ABORT)
	latest-typecheck @ [compile] literal
	compile ?typecheck ; immediate
: ?T	[compile] assert-type ; immediate
								\\ Typecheck implementation

: xtlit		@skip ;
: xtliteral	compile xtlit , ; immediate
: [']      	' [compile] xtliteral ; immediate

T: lit		skip ~Number ;T
T: xtlit	skip ~Xt ;T
T: emit		1 ?D ~Number ?T ;T
T: (")		(")-skip ~'#Str ;T
T: count 	1 ?D ~'#Str ?T ~Str ~Number ;T
T: type 	2 ?D ~Number ?T ~Str ?T ;T
T: >name	1 ?D ~Xt ?T ~'#Str ;

T: (does>)	1 ?D ~Number ?T ;T	\\ TODO ~Xt xtlit/xtliteral ?
T: xexit	;T

T: ?branch	1 ?D ~Any ?T skip ;T
T: branch	skip ;T

T: allot	1 ?D ~Number ?T ;T
T: ,		1 ?D _ ;T
T: |		." |" 1 ?D | ;T
T: _		1 ?D _ ;T
T: ><		2 ?D >< ;T
T: >|		2 ?D >| ;T
T: >|>|		2 ?D >|>| ;T
T: shl		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: @		1 ?D ~Adr ?T ~Number ;T
T: !		2 ?D ~Adr ?T _ ;T
T: 1+		1 ?D ;T
T: 1-		1 ?D ;T
T: +		2 ?D 
		| ~Number T~ if >< | ~Number T~ if _ _ ~Number Texit then | ~Adr T~ if _ _ ~Adr Texit then else 
		| ~Adr    T~ if >< | ~Number T~ if _ _ ~Adr Texit then then
		then yellow ." '+' accepts two numbers, number and address or address and number, got " 
		blue .type yellow ."  and " blue .type norm cr abort ;T
T: -		2 ?D 
		| ~Number T~ if >< | ~Number T~ if _ _ ~Number Texit then else 
		| ~Adr    T~ if >< | ~Number T~ if _ _ ~Adr Texit then then
		then yellow ." '-' accepts numbers or address and number, got " 
		blue .type yellow ."  and " blue .type norm cr abort ;T

								\\ Typechecking implementation
\\ Stack
\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
: stack    0 , | , cells allot does> ;				\ ( n -- ) ( -- stack )	Stack N cells size
: empty    0 >< ! ;						\ ( stack -- )		Empty stack
: stack@   | @ >| cell+ @ ;					\ ( stack -- stack pointer limit )	Extracts stack parameters onto data stack
: .stack   | @ | if >< cell+ cell+ >< for | @ . cell+ over _	\ ( stack -- )
           else _ _ then ;

: >s       | @ >| cell+ @					\ ( a stack -- | E )    Pushes element onto stack or aborts on overflow
	   >| - if						\ ( a stack sp limit )	Check if stack about to overflow
	   >|>| 1+ >< !						\ ( a stack sp )	Increment stack pointer
           cells + cell+ cell+ !				\ ( a stack sp )	Store element
	   else _ >name count type bl emit
	   0add bad57ac .abort then ;				\ 			Stack overflow

: s>       | @ | if						\ ( stack -- a | E )	Pops element off stack or aborts on underflow
           1- >|>| >< !						\ ( stack sp )		Decrement stack pointer
           cells + cell+ cell+ @				\ ( stack sp )		Fetch element
	   else _ >name count type bl emit
	   05bb bad57ac .abort then ;				\			Stack underflow
\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

: qq ." AAA" ;
: qq1 >name count type ;
: qq2 0 >name count type ;

: tqq ['] qq typecheck  ;
: tqq1 ['] qq ['] qq1 typecheck ;
: tqq2 ['] qq2 typecheck ;

T: stack	1 ?D ~Number ?T ;T

: s1	stack ;
: s2	10 stack ;
:: ss	s2

: ts1	['] s1 typecheck ;
: ts2	['] s2 typecheck ;
: ts3	['] ts1 ['] stack typecheck ;

: >s2	| @ >| cell+ @
	>| - if	
	>|>| 1+ >< !
	cells + cell+ cell+ !
	else _ >name count type bl emit
	0add bad57ac .abort then ;

: s5	| @ >| cell+ @ 
	>| - if
	>|>| 1+ >< !
	cells + cell+ cell+ !
	else \ _ >name
	then 
	1 | _ ;

T: s5	." mmmmmmmmmmmmmmmmmmmmmmmmmmm" 1 ?D ['] stack ?T  ~Adr ." uuuuuuuuuuuuuuuuuuuuuu" \ ;T...
	\ typechecking interpretation ['] s5             behavior execcfa interpreting! ." wwwwwwwwwwwwwwwwwww" ;T
	typechecking interpretation [ latest-typecheck @ ] literal behavior execcfa interpreting! ." wwwwwwwwwwwwwwwwwww" ;T

\ φ-junction needed to handle else
: ts41	~Number ~Adr ['] >s typecheck ;
: ts42	~Adr ['] s> typecheck ;
: ts5	~Number ~Adr ['] s5 typecheck ;	
: ts51	~Number ['] stack ['] s5 typecheck ;	
: ts52	~Adr    ['] stack ['] s5 typecheck ;	

: zz    1 ;
T: zz   ~Adr ;T

: p1	['] p1 ['] p1 + ;
: p2	zz zz + ;
: p3	10 zz + ;
: pp4	10 20 + ;
: p4	pp4 30 + ;
: p5	10 20 30 + + ;
: tp1	['] p1 typecheck ;
: tp2	['] p2 typecheck ;
: tp3	['] p3 typecheck ;
: tp4	['] p4 typecheck ;
: tp5	['] p5 typecheck ;

: tpr1
	~Number ~Number	T~ .. .S cr
	~Number ~Any	T~ .. .S cr
	~Any ~Number	T~ .. .S cr
	~Adr ~Number	T~ .. .S cr
;

: w1	41 emit ;
: w2	emit ;			\ ['] <...> generates LIT, which is of type ~Number
: w3	ss emit ;
: tw1	['] w1 typecheck ;
: tw2	['] s2 ['] w2 typecheck ;
: tw3	['] w3 typecheck ;	\ Need <DOES for types

