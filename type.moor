\
\\ Type check
\
								\\ Static type check
:: TYPECHECKING		:state

:: latest-typecheck	latest var

INTERPRETING ' exit 	     behavior TYPECHECKING ' exit          does
INTERPRETING ' interpreting! behavior TYPECHECKING ' interpreting! does

:: TYPECHECKING!!  code rstate TYPECHECKING  mov.i, ret,		\ ( -- )	Sets state to TYPECHECKING without address interpreter involvement
\\	INTERPRETING latest behavior REGALLOCING latest does
								\\ Type registration
:: ~Number
:: ~Xt
:: ~Adr

:: ~'#Str							\ Pointer to a counted string
:: ~#Str							\ Counted string length
:: ~Str								\ String slice

: T:								\ ( "<name>" -- )	Defines static typecheck behavior for a word
	here exec TYPECHECKING ' | latest-typecheck ! does
        compile interpreting!
	] 
;
: ;T	compile TYPECHECKING!! compile exit [compile] [ ; immediate

: typecheck							\ ( xt -- )		Run XT in static type checking mode
	TYPECHECKING state!
	execute
	interpreting! INTERPRETING state! ;

: (:)      : ;							\ 			Redefine : to enable REGALLOCING state TODO: ANALYZE
: :        (:) INTERPRETING latest behavior TYPECHECKING latest does ;

: ?depth
	>< || < if >>>
		blue .name bl emit
		yellow ." depth: expected " blue . bs yellow ." , got " blue . norm cr abort 
	then _ _ _ ;
: ?D	
	compile depth compile 1- latest-typecheck @ [compile] literal compile <<< compile ?depth ; immediate

: T~	= ; 

: ?typecheck
	<<< || T~ -if >>>
		blue .name bl emit
		yellow ." typecheck error:" 
		blue ."  expected " yellow .name 
		blue ." , received " yellow .name norm cr abort 
	then _ _ _ ;
: assert-type							\ ( t1 t2 -- | ABORT)
	latest-typecheck @ [compile] literal
	compile ?typecheck ; immediate
: ?T	[compile] assert-type ; immediate
								\\ Typechecking tests
.( Typechecking ) cr

T: lit		skip ~Number ;T
T: emit		1 ?D ~Number ?T ;T
T: (")		(")-skip ~'#Str ;T
T: count 	1 ?D ~'#Str ?T ~Str ~Number ;T
T: type 	2 ?D ~Number ?T ~Str ?T ;T
T: >name	~Xt ?T ~'#Str ;

T: (does>)	1 ?D ~Number ?T ;T	\\ TODO ~Xt xtlit/xtliteral ?
T: xexit	;T
T: allot	1 ?D ~Number ?T ;T
T: ,		1 ?D _ ;T
T: |		1 ?D | ;T
T: >|		2 ?D >| ;T
T: >|>|		2 ?D >|>| ;T
T: shl		2 ?D ~Number ?T ~Number ?T ~Number ;T
T: @		1 ?D ~Adr ?T ~Number ;T
T: +		2 ?D .S cr
		| ~Number T~ if | .name _ | ~Number T~ if | .name _ exit then | ~Adr T~ if | .name _ exit then else 
		| ~Adr    T~ if | .name _ | ~Number T~ if | .name _ exit then then
		then .S abort" '+' accepts numbers or address and number" ;

: qq ." AAA" ;
: qq1 >name count type ;
: qq2 0 >name count type ;

: tqq ['] qq typecheck  ;
: tqq1 ['] qq ['] qq1 typecheck ;
: tqq2 ['] qq2 typecheck ;

\\ Stack
\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
: stack    0 , | , cells allot does> ;				\ ( n -- ) ( -- stack )	Stack N cells size
: empty    0 >< ! ;						\ ( stack -- )		Empty stack
: stack@   | @ >| cell+ @ ;					\ ( stack -- stack pointer limit )	Extracts stack parameters onto data stack
: .stack   | @ | if >< cell+ cell+ >< for | @ . cell+ over _	\ ( stack -- )
           else _ _ then ;

: >s       | @ >| cell+ @					\ ( a stack -- | E )    Pushes element onto stack or aborts on overflow
	   >| - if						\ ( a stack sp limit )	Check if stack about to overflow
	   >|>| 1+ >< !						\ ( a stack sp )	Increment stack pointer
           cells + cell+ cell+ !				\ ( a stack sp )	Store element
	   else _ >name count type bl emit
	   0add bad57ac .abort then ;				\ 			Stack overflow

: s>       | @ | if						\ ( stack -- a | E )	Pops element off stack or aborts on underflow
           1- >|>| >< !						\ ( stack sp )		Decrement stack pointer
           cells + cell+ cell+ @				\ ( stack sp )		Fetch element
	   else _ >name count type bl emit
	   05bb bad57ac .abort then ;				\			Stack underflow
\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

T: stack	1 ?D ~Number ?T ;T



: s1	stack ;
: s2	10 stack ;

: ts1	['] s1 typecheck ;
: ts2	['] s2 typecheck ;
: ts3	['] ts1 ['] stack typecheck ;

: ts4	~Adr ['] >s typecheck ;

: zz    1 ;
T: zz   ~Adr ;T

: p1	['] p1 ['] p1 + ;
: p2	zz zz + ;
: p3	10 zz + ;
: tp1	['] p1 typecheck ;
: tp2	['] p2 typecheck ;
: tp3	['] p3 typecheck ;


