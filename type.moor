\
\\ Type check
\
								\\ Static type check
:: TYPECHECKING		:state

:: latest-typecheck	latest var

INTERPRETING ' exit 	     behavior TYPECHECKING ' exit          does
INTERPRETING ' interpreting! behavior TYPECHECKING ' interpreting! does

:: TYPECHECKING!!  code rstate TYPECHECKING  mov.i, ret,		\ ( -- )	Sets state to TYPECHECKING without address interpreter involvement
\\	INTERPRETING latest behavior REGALLOCING latest does
								\\ Type registration
:: ~Number
:: ~Xt

:: ~'#Str							\ Pointer to a counted string
:: ~#Str							\ Counted string length
:: ~Str								\ String slice

: T:								\ ( "<name>" -- )	Defines static typecheck behavior for a word
	here exec TYPECHECKING ' | latest-typecheck ! does
        compile interpreting!
	] 
;
: ;T	compile TYPECHECKING!! compile exit [compile] [ ; immediate

: typecheck							\ ( xt -- )		Run XT in static type checking mode
	TYPECHECKING state!
	execute
	interpreting! INTERPRETING state! ;

: (:)      : ;							\ 			Redefine : to enable REGALLOCING state TODO: ANALYZE
: :        (:) INTERPRETING latest behavior TYPECHECKING latest does ;

: assert-depth depth < if 71bececc deb76 .abort then ;

: .typecheck-error yellow ." typecheck error" norm cr ;
: assert-type							\ ( t1 t2 -- | ABORT)
	compile <>
	[compile] if
		latest-typecheck @ [compile] literal
		compile >name compile count compile blue compile type 
		compile bl compile emit compile .typecheck-error
	[compile] then
; immediate
: ?T [compile] assert-type ; immediate
								\\ Typechecking tests
.( Typechecking ) cr

T: lit	skip ~Number ;T
T: emit ~Number ?T ;T
T: (") (")-skip ~'#Str ;T
T: count ~'#Str ?T ~Str ~Number ;T
T: type ~Number ?T ~Str ?T ;T




: qq ." AAA" ;
: qq1 ['] qq 10 type ;
: tqq ['] qq trace typecheck notrace ;


