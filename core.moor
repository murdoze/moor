: \ 0 word drop ; immediate
: \\ 0 word drop ; immediate
\
\\ Moor Forth System
\
\\ Index:		Press <S-8>=<*> to navigate in Vim
\\ _core_core
\\ _var_val
\\ _states
\\ _control
\\ _search
\\ _print
\\ _assembler
\\ _memory
\\ _return_stack
\\ _loops
\\ _stack
								\\ Vocabularies

: vocabulary create current @ , does> context ! ;
: definitions context @ current ! ;

								\\ Comments and debug output
								\\ Register assignment. Should be changed if register aliases are changed
: r0       01 ;							\ rcx = rtop
: rtop     01 ;
: rcx	   01 ;
: r1       02 ;							\ rdx = rtmp
: rtmp     02 ;
: rdx      02 ;
: r2       00 ;							\ rax = rwork
: rwork    00 ;
: rax      00 ;
: rstate   03 ;							\ rbx = rstate
: rsp      04 ;							\ rsp
: rstack   05 ;							\ rbp = rstack
: rsi      06 ;							\ rsi = rpc
: rpc      06 ;							\ rsi = rpc
: rdi      07 ;							\ rdi = rhere
: rhere    07 ;							\ rdi = rhere
: r8       08 ;
: r9       09 ;
: rindex   0a ;							\ r10 = rindex
: r10      0a ;							\ r10 = rindex
: rend     0c ;							\ r12 = rend
: rnext    0d ;							\ r13 = rnext
: rstack0  0f ;							\ r15 = rstack0

: #_0 0 ;							\ Offset of the first available stack item
: #_1 8 ;							\ Offset of the second stack item
: #_2 10 ;							\ Offset of the third stack item

								\\ Basic assembler for r0-r7. Stack access is hardcoded

: `        c, ;							\ Compile single byte

: rex,     48 ` ;
: rex1,    49 ` ;

: call0,   e8 ` 00 ` 00 ` 00 ` 00 ` ;				\ ( -- )		call	0f; 0: ...
: ret,     c3 ` ;						\ ( -- )		ret
: retfq,   rex, cb ` ;						\ ( -- )		retfq
: iretq,   rex, cf ` ;						\ ( -- )		iretq

: cs,      8c ` c9 ` ;						\ ( -- cs )		mov 	ecx, cs
: ds,      8c ` d9 ` ;						\ ( -- ds )		mov	ecx, ds

: ds!,     8e ` d9 ` ;						\ ( ds -- )		mov	ds, cx
: es!,     8e ` c1 ` ;						\ ( ds -- )		mov	ds, cx
: fs!,     8e ` e1 ` ;						\ ( ds -- )		mov	ds, cx
: gs!,     8e ` e9 ` ;						\ ( ds -- )		mov	ds, cx

:: 1+      code rex, ff ` c1 ` ret,				\ ( n -- n+1)		inc	r0
:: 1-      code rex, ff ` c9 ` ret,				\ ( n -- n-1)		dec	r0

: shl0,    rex, c1 ` e1 ` ` ;					\ ( n -- )		shl	r0, n
: shl1,    rex, c1 ` e2 ` ` ;					\ ( n -- )		shl	r1, n
:: shl1#3  code	3 shl1,	ret,					\ ( -- )		shl	r1, 3

: off,     rex, ff ` c5 ` ;					\ ( -- )		inc	rstack
: on,      rex, ff ` cd ` ;					\ ( -- )		dec	rstack
:: off     code off, ret,					\ ( a b -- b )

: (load,   rex1, 8b ` ;
: (store,  rex1, 89 ` ;
: load),   ef ` ` ;
: store),  ef ` ` ;
: load1,   (load, 54 ` #_1 load), ;				\ ( -- )		mov	r1, [S+8]
:: load1   code load1, ret,

: (or),    rex, 09 ` ;
: or01,    (or), d1 ` ;						\ ( -- )		or	r0, r1
:: or01    code or01, ret,

: modrm,   c0 load1 shl1#3 or01 off load1 or01 ` drop ;		\ ( rd rs -- )		Compiles ModR/M byte

: or,	   (or), modrm, ;					\ ( rd rs -- )		or	Rd, Rs
:: or	   code load1, r0 r1 or, off, ret,

: (and),    rex, 21 ` ;
: and,	   (and), modrm, ;					\ ( rd rs -- )		and	Rd, Rs
:: and	   code load1, r0 r1 and, off, ret,

: (mov),   rex, 89 ` ;
: mov,     (mov), modrm, ;					\ ( rd rs -- )		mov	Rd, Rs	# s, d <= 7

: shl,     rex, d3 ` e0 or ` ;					\ ( rd -- )		shl	Rd, cl
:: shl     code load1, r1 shl, r0 r1 mov, off, ret,		\ ( n u -- u<<n )	mov	r1, [S+8] ; shl r1, r0l ; mov r0, r1 ; inc rstack	
: sar,     rex, d3 ` f8 or ` ;					\ ( rd -- )		sar	Rd, cl
:: sar     code load1, r1 sar, r0 r1 mov, off, ret,		\ ( n u -- u>>n )	mov	r1, [S+8] ; sal r1, r0l ; mov r0, r1 ; inc rstack	

: load,    (load,  3 shl 44 or ` load), ; 			\ ( # rd -- )		mov	Rd, [S+#]
: store,   (store, 3 shl 44 or ` store), ;		 	\ ( # rs -- )		mov	[S+#], Rs

								\ Basic subtraction is needed to implement control structures
: (add),   rex, 01 ` ;
: (sub),   rex, 29 ` ;
: add,     (add), 3 shl c0 or r0 or ` ;				\ ( rs -- )		add	r0, Rs
: sub,     (sub), c0 or r0 3 shl or ` ;				\ ( rd -- )		sub	Rd, r0
:: +       code #_1 r1 load, r1 add, off, ret,			\ ( n1 n2 -- n1+n2 )	mov	r1, [S+8] ; add r0, r1 ; inc rstack
:: -       code #_1 r1 load, r1 sub, r0 r1 mov, off, ret,	\ ( n1 n2 -- n1-n2 )	mov	r1, [S+8] ; sub r1, r0 ; mov r0, r1 ; inc rstack

								\\ Basic math continued
: 2/       1 sar ;						\ ( n -- n/2)
: 4/       2 sar ;
: 8/       3 sar ;
: 2*       1 shl ;
: 4*       2 shl ;
: 8*       2 shl ;
								\\ Cells									_core_core
: cell     8 ;							\ ( -- 8 )		Size of one cell
: cells    3 shl ;						\ ( n -- n*8 )		Convert size in cells to size in bytes
: cell/	   3 sar ;						\ ( n -- n/8 )		Convert size in bytes to size in cells
: cell+    cell + ;

								\\ Stack manipulation words with modern and fancy names not without visual semantics
: _,       #_1 r0 load, off, ;					\ ( a -- )		drop
: |,       #_0 r0 store, on, ;					\ ( a -- a a )		dup
: ><,      #_1 r1 load, #_1 r0 store, r0 r1 mov, ;		\ ( a b -- b a )	swap
: >|,      #_1 r1 load, on, #_1 r0 store, r0 r1 mov, ;		\ ( a b -- a b a )	over
: >|>|,    #_1 r1 load, on, #_1 r0 store, on, #_1 r1 store, ;	\ ( a b -- a b a b )	2dup = over over
: >>>,     #_1 r1 load, #_2 r2 load,				\ ( a b c -- b c a )	roT
           #_2 r1 store, #_1 r0 store, r0 r2 mov, ;
: <<<,     #_1 r1 load, #_2 r2 load,				\ ( a b c -- c a b )	-rot
           #_2 r0 store, #_1 r2 store, r0 r1 mov, ;

:: _       code _, ret,
:: |       code |, ret,
:: ><      code ><, ret,
:: >|      code >|, ret,
:: >|>|    code >|>|, ret,
: ||       >|>| ;
:: >>>     code >>>, ret,
:: <<<     code <<<, ret,

: #|       pick ;						\ WARNING! Generic PICK is not compileable, as it references an unknown stack element!
: >>|      2 pick ;

								\\ Memory access words
:: c@      code rex, 0f ` b6 ` 09 ` ret,			\ ( a -- [a] )		movzx	r0, byte ptr [r0]
:: 2@      code rex, 0f ` b7 ` 09 ` ret,			\ ( a -- [a] )		movzx	r0, word ptr [r0]
:: 4@      code 8b ` 09 ` ret,					\ ( a -- [a] )		mov	r0d, dword ptr [r0]
:: @       code rex, 8b ` 09 ` ret,				\ ( a -- [a] )		mov	r0, [r0]

:: c!      code #_1 r1 load, rex, 88 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #_0 r0 load, ret,					\			mov	r0, [S+8]
:: 2!      code #_1 r1 load, 66 ` 89 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #_0 r0 load, ret,					\			mov	r0, [S+8]
:: 4!      code #_1 r1 load, 89 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #_0 r0 load, ret,					\			mov	r0, [S+8]
:: !       code #_1 r1 load, rex, 89 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #_0 r0 load, ret,					\			mov	r0, [S+8]

								\\ Variables and constants							_var_val
: adr      does> ;						\ :: a adr
: var      , does> ;						\ :: a 12345 var
: val      , does> @ ;						\ :: b 98765 val


: >name    22 cells - @ ; 					\ ( xt -- c-addr )	Returns address of the name counted string
: >link    21 cells - ; 					\ ( xt -- lfa )		Returns address of the LFA

: .name    >name count type ;
								\\ Control structures								_control
: >mark    here 0 , ;						\ ( -- a )		Address for forward branch fixup
: >resolve | here >< - cell/ 1- >< ! ;				\ ( a -- )		Fixup forward branch

: <mark    here ;						\ ( -- a )		Address for backward branch fixup
: <resolve here  - cell/ 1- , ;

								\ These words do the job during register allocation and do nothing during execution
: (if) ;
: (if-post) ;
: (else-pre) ;
: (else-post) ;
: (then) ;
: (begin) ;
: (until) ;
: (again) ;
: (ahead) ;
: (while) ;
: (repeat-pre) ;
: (repeat-post) ;
: (continue) ;
: (break) ;
								\ ... begin ... -? until ...
								\ ... begin ... again ...
								\ ... begin ... ? while ... repeat ...	
								\ ... begin ... ? continue ... ? break ... [while] ... repeat|again ... then	
								\ TODO: Allow for multiple BREAKs, as with CONTINUE

: if       ?comp compile (if) compile ?branch >mark compile (if-post) ; immediate
: -if      ?comp compile (if) compile -?branch >mark ; immediate
: else     ?comp compile (else-pre) compile branch >mark compile (else-post) >< >resolve ; immediate
: then     ?comp compile (then) >resolve ; immediate
: begin    ?comp compile (begin) <mark ; immediate
: until    ?comp compile (until) compile ?branch <resolve ; immediate
: again    ?comp compile (again) compile branch <resolve ; immediate
: ahead    ?comp compile (ahead) compile branch >mark ; immediate
: while    ?comp compile (while) compile ?branch >mark ; immediate
: repeat   ?comp compile (repeat-pre) compile branch >< <resolve compile (repeat-post) >resolve ; immediate
: continue ?comp compile (continue) compile -?branch | <resolve ; immediate
: break    ?comp compile (break) compile -?branch >mark >< ; immediate

: norm     baremetal? if 01 emit 07 emit else 1b emit 5b emit 30 emit 6d emit then ;
: red      baremetal? if 01 emit 04 emit else 1b emit 5b emit 33 emit 31 emit 6d emit then ;
: green    baremetal? if 01 emit 02 emit else 1b emit 5b emit 33 emit 32 emit 6d emit then ;
: yellow   baremetal? if 01 emit 0e emit else 1b emit 5b emit 33 emit 33 emit 6d emit then ;
: blue     baremetal? if 01 emit 09 emit else 1b emit 5b emit 33 emit 34 emit 6d emit then ;
: purple   baremetal? if 01 emit 05 emit else 1b emit 5b emit 33 emit 35 emit 6d emit then ;
: white    baremetal? if 01 emit 0f emit else 1b emit 5b emit 33 emit 37 emit 6d emit then ;
: .\       0 word count blue type norm 0a emit ;
: .(       29 word count purple type norm ; immediate
: cr       0a emit ;
: tab      09 emit ;
: bs       08 emit ;
: ..       blue . norm ;
: ??       dup .. ;
								\\ Debug output
: ..S .S ;
: .S blue ..S bl emit norm ;					\ Blue stack

								\\ Abort
:: testing 		0 var					\ In testing mode?
:: test-result		0 var
: test-failed	0 test-result ! ;

: (abort)	abort ;
: abort		testing @ if 0 test-result ! raise else (abort) then ;

: .abort   red . . norm cr abort ;				\ ( code message -- )	Prints code and message as hexadecimal numbers and aborts
								

								\\ Search									_search

: '        bl word _ find					\ ( "<name>" -- xt | E )
           | if else badd1c 071cf10d .abort then ;
: compile, , ;							\ ( xt -- )		Compiles XT on the top of the stack into current definition
: [compile] ' compile, ; immediate				\ ( "<name>" -- )	Compiles XT of the next word in the input stream
: [']      ' [compile] literal ; immediate			\ ( "<name>" -- )	Compiles XT of the next word in the input stream as a literal
: ?execute | if execute else _ then ;				\ ( xt | 0 -- )		Execute if not zero

: ."       ?comp [compile] " compile count compile type ; immediate
: abort"   compile cr compile red [compile] ." compile norm compile cr compile abort ; immediate



								\\ Debugging / tracing
: ntrace   ' trace execute notrace ;				\ ( "<name>" -- )	Runs in no-debug trace mode
: dtrace   ' nodebug debug trace execute notrace ;		\ ( "<name>" -- )	Runs in debug trace mode

								\\ Improved assembler, r0-15 support						_assembler
: rex      150b501e7e 0c0de .abort ;				\ Obsolete
: rex.     40 ;
: rex.b    rex. ;						\ REX operand size determined by CS.D
: rex.q    rex. 08 or ;						\ REX specifies 64-bit operands
: rex?     08 and ;						\ ( r -- f )	 	Checks if R is an extended regsiter (R8-R15)
: rex.rd   >< rex? if 01 or then ;				\ ( rd rex' -- rex'' )	REX part with Rd bit set
: rex.rs   >< rex? if 04 or then ;				\ ( rd rex' -- rex'' )	REX part with Rd bit set
: rexrr.q  rex.q rex.rs rex.rd ;				\ ( rd rs -- rex )	Returns REX prefix for Rd and Rs
: rexrd.q  rex.q rex.rd ;					\ ( rd -- rex )		Returns REX prefix for Rd
: rexrs.q  rex.q rex.rs ;					\ ( rs -- rex )		Returns REX prefix for Rs
: rd       07 and ;						\ ( rd -- modrm' )	Returns ModR/M byte part for Rd
: rs       07 and 3 shl ;						\ ( rs -- modrm' )	Returns ModR/M byte part for Rs
: rr       c0 ;							\ (  -- modrm' )	Returns ModR/M byte part for RR
: modrr    rs >< rd or rr or ;					\ ( rd rs -- modrm )	Returns ModR/M byte for Rd and Rs
: modro    >< rd or rr or ;					\ ( rd op -- modrm )	Returns ModR/M byte for Rd and opcode
: instrr   c, does> <<< >|>| rexrr.q ` >>> c@ ` modrr ` ;	\ ( op -- ) ( rd rs a -- )
: instrr2  c, c, does> <<< >|>| >< rexrr.q ` >>> | c@ `		\ ( op1 op2 -- ) ( rd rs a -- )
           1+ c@ ` >< modrr ` ;
: instro   c, c, does> >< | rexrd.q ` >< | c@ `			\ ( op1 op2 -- ) ( rd a -- )
           1+ c@  modro ` ;
: instroi4 c, c, does> >< <<< >< | rexrd.q ` >< | c@ `		\ ( op1 op2 -- ) ( rd imm32 a  -- )
		   1+ c@  modro ` 4, ;
: instroi1 c, c, does> >< <<< >< | rexrd.q ` >< | c@ `		\ ( op1 op2 -- ) ( rd imm8 a  -- )
           1+ c@  modro ` c, ;
: instpp   c, does> c@ >< | rex? if 41 ` then 7 and or ` ; 	\ ( op -- ) ( rd a -- )	Push/pop instruction

								\\ Condition codes and conditional set instructions
:: .o      00 val
:: .no     01 val
:: .b      02 val
:: .c      02 val
:: .nae    02 val
:: .nb     03 val
:: .ae     03 val
:: .e      04 val
:: .z      04 val
:: .ne     05 val
:: .nz     05 val
:: .be     06 val
:: .na     06 val
:: .nbe    07 val
:: .a      07 val
:: .s      08 val
:: .ns     09 val
:: .p      0a val
:: .pe     0a val
:: .np     0b val
:: .po     0b val
:: .l      0c val
:: .nge    0c val
:: .nl     0d val
:: .ge     0d val
:: .le     0e val
:: .ng     0e val
:: .nle    0f val
:: .g      0f val

:: setf.op 90 val						\ SETcc opcode
: setf,    rex.b ` 0f ` setf.op or ` rd rr or ` ;		\ ( rd cond -- )	set.cc rd

:: j.op    70 val						\ Jcc opcode
: j,       j.op or ` ` ;					\ ( offset cond -- )	j.cc	offset8

:: lj.op   80 val						\ lJcc opcode		Long jump conditional
: lj,      0f ` lj.op or ` 4, ;					\ ( offset cond -- )	j.cc	offset32

: sjmp,    eb ` ` ;						\ ( offset -- )         Short jump
: ljmp,    e9 ` 4, ;						\ ( offset -- )         Long/near jump
								\\ Arithmetic, logic and moves
:: movzx.op b6 val						\ MOVZX opcode
: movzx,   rex.q ` 0f ` movzx.op ` modrr ` ;			\ ( rd rs -- )		movzx	rdl, rs

:: mov,    89 instrr						\ ( rd rs -- )		mov	rd, rs
:: test,   85 instrr						\ ( rd rs -- )		test	rd, rs
:: add,    01 instrr						\ ( rd rs -- )		add	rd, rs
:: sub,    29 instrr						\ ( rd rs -- )		sub	rd, rs
:: or,     09 instrr						\ ( rd rs -- )		or	rd, rs
:: and,    21 instrr						\ ( rd rs -- )		and	rd, rs
:: xor,    31 instrr						\ ( rd rs -- )		xor	rd, rs
:: cmp,    39 instrr						\ ( rd rs -- )		cmp	rd, rs

:: inc,    00 ff instro						\ ( rd -- )		inc	rd
:: dec,    08 ff instro						\ ( rd -- )		dec	rd
:: call,   10 ff instro						\ ( rd -- )		call	rd
:: jmp,    e0 ff instro						\ ( rd -- )		jmp	rd
:: neg,    d8 f7 instro						\ ( rd -- )		neg	rd
:: not,    d0 f7 instro						\ ( rd -- )		not	rd

:: imul,   af 0f instrr2					\ ( rd rs -- )		imul	rd, rs

:: mov.i,  00 c7 instroi4					\ ( rd imm32 -- )	mov	rd, imm32
:: add.i,  c0 83 instroi1
:: sub.i,  e8 83 instroi1

:: push,   50 instpp						\ ( rs -- )		push	rs
:: pop,    58 instpp						\ ( rd -- )		pop	rd

: nop,     90 ` ;

:: *       code rtmp rtop mov, _, rtop rtmp imul, ret,		\ ( a b -- a*b )

:: xor     code #_1 r1 load, r0 r1 xor, off, ret,		\ ( n1 n2 -- n1 xor n2 )


								\ Parameters: rax rdi rsi rdx r10 r8 r9
: syscall, 0f ` 05 ` ;
:: syscall code rax rtop mov, syscall, rtop rax mov, ret,
:: syscall1 code rdi push,
            rax rtop mov, _, rdi rtop mov,
            syscall,
            rtop rax mov,
	    rdi pop, ret,
:: syscall2 code rdi push, rsi push,
            rax rtop mov, _, rdi rtop mov,
            syscall,
	    rtop rax mov,
	    rsi pop, rdi pop,
	    ret,
:: syscall3 code rdi push, rsi push,
            rax rtop mov, _, rdi rtop mov, _, rsi rtop mov, _,
	    rdx rtop mov,
            syscall,
	    rtop rax mov,
	    rsi pop, rdi pop,
	    ret,
:: syscall4 code rdi push, rsi push, r10 push,
            rax rtop mov, _, rdi rtop mov, _, rsi rtop mov, _,
	    rdx rtop mov, _, r10 rtop mov,
            syscall,
	    rtop rax mov,
	    r10 pop, rsi pop, rdi pop,
	    ret,
:: syscall5 code rdi push, rsi push, r10 push,
            rax rtop mov, _, rdi rtop mov, _, rsi rtop mov, _,
	    rdx rtop mov, _, r10 rtop mov, _, r8 rtop mov,
            syscall,
	    rtop rax mov,
	    r10 pop, rsi pop, rdi pop,
	    ret,
:: syscall6 code rdi push, rsi push, r10 push,
            rax rtop mov, _, rdi rtop mov, _, rsi rtop mov, _,
	    rdx rtop mov, _, r10 rtop mov, _, r8 rtop mov, _, r9 rtop mov,
            syscall,
	    rtop rax mov,
	    r10 pop, rsi pop, rdi pop,
	    ret,

: rdtsc,   0f ` 31 ` ;						\			RDTSC EDX:EAX
:: timestamp code 						\			64-bit timestamp
           |, rdtsc, rtop rdx mov, 20 shl0, rtop rax or, ret,


: movzxc,  48 ` 0f ` b6 ` c9 ` ;				\			movzx	rcx, cl
: xchg01, 48 ` 87 ` d1 ` ;					\			xchg	rcx, rdx
: setnz,  r0 .nz setf, movzxc, ;				\ 			setnz	cl ; movzx rcx, cl
: setz,   r0 .z setf,  movzxc, ;				\ 			setz	cl ; movzx rcx, cl
: setc,   r0 .c setf,  movzxc, ;				\ 			setc	cl ; movzx rcx, cl
: setl,   r0 .l setf,  movzxc, ;				\ 			setl	cl ; movzx rcx, cl
: setle,  r0 .le setf, movzxc, ;				\ 			setle	cl ; movzx rcx, cl
: setg,   r0 .g setf,  movzxc, ;				\ 			setl	cl ; movzx rcx, cl
: setge,  r0 .ge setf, movzxc, ;				\ 			setle	cl ; movzx rcx, cl

:: =       code #_1 r1 load, r1 r0 cmp, setz, off, ret,		\ ( a b -- a=b )	Compare two top elements, return 1 if equal and 0 otherwise
:: <>      code #_1 r1 load, r1 r0 cmp, setnz, off, ret,	\ ( a b -- a<>b )	Compare two top elements, return 1 if not equal and 0 otherwise
:: <       code #_1 r1 load, r1 r0 cmp, setl, off, ret,		\ ( a b -- a<b )	
:: <=      code #_1 r1 load, r1 r0 cmp, setle, off, ret,	\ ( a b -- a<=b )	
:: >       code #_1 r1 load, r1 r0 cmp, setg, off, ret,		\ ( a b -- a>b )	
:: >=      code #_1 r1 load, r1 r0 cmp, setge, off, ret,	\ ( a b -- a>=b )	
								\\ Control structures: helpers
: lodsq,   48 ` ad ` ;						\			lodsq	rax, qword ptr [rsi]
: skip,    48 ` 8d ` 34 ` c6 ` ;				\			lea	rsi, [rsi + rax*8]
								\\ Interrupts
: hlt,     f4 ` ;
: cli,     fa ` ;
: sti,     fb ` ;

:: skip    code rtmp pop, rwork pop, 				\ ( -- )		Skip next address interpreter word TODO: make single ADD
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork push, rtmp push, ret,
:: @skip   code |, rtmp pop, rwork pop,				\ ( -- a )		Skip next address interpreter word, and return it
                48 ` 8b ` 08 `         				\			mov rtop, [rwork]
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork push, rtmp push, ret,

:: self    code |, rtop rpc mov, rtop 8 sub.i, ret,		\ ( a -- )		Returns RPC for the calling word
								\			If SELF is the first compiled word, it returns caller's XT
								\\ Stack, continued
: depth,   #_0 rtop store, rtop rstack mov, rtop neg, on, ;	\ ( -- # )		Stack depth 
:: depth   code depth, ret,
								\\ States									_states
:: MAX_STATE	 0 var
: :state   MAX_STATE @ | -20 > if | val 2 - MAX_STATE !
           else .. bad57a7e 0f10 .abort then ;
								\\ Debug
								\\ Dictionary structure manipulation
: >cfa     cells + cell - cell - ;				\ ( xt state -- cfa )	Returns CFA for given state for XT
: cfa@     | @ >< cell + @ >< ;					\ ( cfa -- param code )	Returns param and code for CFA
: >cfa@    >cfa cfa@ ;						\ ( xt state -- param code)	Returns param and code for given state for XT
: behavior >< >cfa@ ;						\ ( state xt -- param code)	Same as >cfa@, with input parameters swapped for aesthetics
: exec     (exec) ;						\ ( -- _exec )			Returns address of _exec entry point (param should point to threaded code)
								\\ Here
:: here!   code rhere rtop mov, _, ret,
								\\ Return stack									_return_stack
:: (>r)    code r1 pop, r0 push, _, r1 push, ret,		\ ( a -- ) ( R: -- a)	Pushes top of parameter stack onto return stack
:: (r>)    code |, r1 pop, r0 pop, r1 push, ret,		\ ( -- a ) ( R: a -- )	Pops top of parameter stack off return stack
: >r       ?comp compile (>r) ; immediate
: r>       ?comp compile (r>) ; immediate
: {        ?comp compile (>r) ; immediate
: }        ?comp compile (r>) ; immediate
: |{       ?comp compile | compile { ; immediate		\ ( a -- a ) ( R: a -- ) Duplicated parameter and pushes it onto return stack
: ||{{     ?comp compile | compile { compile ><			\ ( a b -- a b ) ( R: a b -- ) 	Dupliacted two parameters and pushes them onto return stack
           compile | compile { compile >< ; immediate
: {{       ?comp compile >< compile { compile { ; immediate	\ ( a b -- R: a b )
: }}       ?comp compile } compile } ; immediate		\ ( R: a b -- a b )

								\\ Built-in states
:: INTERPRETING		:state
:: COMPILING   		:state 
:: DECOMPILING		:state
:: REGALLOCING		:state					\ TODO: dirty hack, see _exit_regalloc

: interpretation	INTERPRETING ;
: compilation		COMPILING ;
: decompilation		DECOMPILING ;
								\\ DOES for states
: does<								\ ( code state -- )
          ['] (does) ><
	  compile lit >mark {
	  >< compile,
	  [compile] literal  
	  compile latest
	  compile does 
	  compile branch >mark } here >< ! 
	  compile interpreting!
;
: >does   compile xexit >resolve ;
								\\ Decompilation DOES
: decomp-does<	decompilation does< ; immediate
: >decomp-does	compile decompiling! >does ; immediate

' val : val    [ compile, ] decomp-does< .decomp tab | @ . tab ." val @" . cr >decomp-does ;
' var : var    [ compile, ] decomp-does< .decomp tab | @ . tab ." var @" . cr >decomp-does ;

: -try	if r> then ;
: try	-if r> then ;
								\\ Control structures: loops							_loops
								\ DOC: https://github.com/TG9541/stm8ef/wiki/eForth-FOR-..-NEXT
:: (for)   code rtmp pop, rwork pop, rindex push,  		\ ( n -- )		push rindex; mov rindex, rtop ; drop
                rindex r0 mov,
                rwork push, rtmp push, _, ret,
: (aft) ;
:: I       code |, r0 rindex mov, ret,				\ ( -- I )		Returns FOR loop index
:: (over)  code rindex dec, lodsq, 4 .z j, skip, ret,		\ ( -- )		dec rindex ; lodsq ; jz ret ; rpc+=ofs ; ret
:: (over-post) code
                rtmp pop, rwork pop, rindex pop, 
		rwork push, rtmp push, ret,
DECOMPILING ' branch behavior DECOMPILING ' (over) does

:: (-leave) code 						\ ( f -- )		Leave FOR loop if the flag is false
           rtmp rtop mov,
	   _, lodsq, rtmp rtmp test, 1 .z j, ret,
	   skip,
	   rtmp pop, rwork pop, rindex pop,
	   rwork push, rtmp push, ret,
DECOMPILING ' branch behavior DECOMPILING ' (-leave) does


: for      ?comp compile (for) <mark ; immediate		\ ... n for ... [ aft ] ... [ then ] ... over ...
								\ TODO: ?FOR would be nice to have, but it's needed to pass a flag to OVER to compile THEN
								\       This can be implemented after there is a control stack with checks and other flags
: aft      ?comp compile (aft) compile branch _ >mark <mark >< ; immediate
: -leave   ?comp compile (-leave) >mark >< ; immediate		\ TODO: BUG! Incompatible with nested FORs as it is now
: over     ?comp compile (over) <resolve compile (over-post) ; immediate

								\\ Stack manipulation, continued
: #_       | if for _ over else _ then ;			\ ( a1 ... an n -- )	Drops N elelemns off stack (including count)
: empty-stack	
           depth #_ ;

: >|>|>|   { >|>| } | { <<< } ; 				\ ( a b c -- a b c a b c ) 3OVER

								\\ Arithmetic and logic, continued
:: not     code rtop not, ret,
:: negate  code rtop neg, ret,
								\\ Min and max
: min      >|>| - 0 > if >< then _ ;				\ ( a b -- min(a,b) ) Minimum
: max      >|>| - 0 < if >< then _ ;				\ ( a b -- min(a,b) ) Minimum
								\\ Memory									_memory
: fill     <<< for >|>| c! 1+ over _ _ ;			\ ( a n c -- )		Fill N bytes from address A with character C
: 1+!      | @ 1+ >< ! ;				 	\ ( a -- )		Increment variable at A
: >2^	   1-							\ ( n -- n' )		Align N up to nearest power of 2
           | 1 sar or | 2 sar or | 4 sar or
	   | 8 sar or | 10 sar or | 20 sar or
	   1+ ;
: #aligned >2^ | negate >< 1- >>> + and ;			\ ( a # -- a' )		Align A to #'s nearest power of 2 bytes
: aligned  #aligned ;						\			This looks better, why we need #? TODO
								\\ Bit field access
: bits     shl ;						\ ( value #start-bit -- value_shl_#start-bit )
: bit      1 >< shl ;						\ ( #bit -- value-with-#bit-set )
: set?     and ;
: set      or ;
: reset    not and ;

: bitmask  >< 1 >< shl 1- >< shl ;				\ ( #bits #start-bit -- mask )
: bits?    |{ bitmask and } sar ;				\ ( value #bits #start-bit )
								\\ Characters and strings
: char     bl word count _ c@ ;
: [char]   char [compile] literal ; immediate

: ,"       [char] " word count 1+ >< 1- >< here >< | 		\ ( "ccc" -- )		Compiles byte-counted string at HERE
           allot cmove ; 
: ,0"      [char] " word count here >< |			\ ( "ccc" -- )		Compiles zero-terminated string at HERE
           allot cmove 0 c, ;
	   							\\ Random
:: randseed 7 var						\			https://en.wikipedia.org/wiki/Xorshift
: random32							\ ( -- x )		Return a 32-bit random number X (Xorshift RNG)
    randseed @ ffffffff and
    | 0d shl ffffffff and xor
    | 11 sar ffffffff and xor
    | 5  shl ffffffff and xor
    | randseed ! ;
: random random32 * 20 sar ;					\ ( n -- )		Returns a random number in range 0..N-1
: randomize timestamp ffffffff and randseed ! ;
								\\ Locals on R-stack

:: #r@     code	48 ` 8b ` 4c ` cc ` 08 ` ret,			\ ( # -- #r )  		mov rtop, [rsp + rtop * 8 + 8]
:: #r!     code							\ ( v # --  )  		mov [rsp + rwork * 8 + 8], rtop
		rwork rtop mov, _,
		48 ` 89 ` 4c ` c4 ` 08 ` _, ret,


:: #l@     code 49 ` 8b ` 4c ` c8 ` 08 ` ret,			\ ( # -- #r )		mov rtop, [r8 + rcx * 8 - 8]
:: #l!     code							\ ( v # --  )  		mov [r8 + rwork * 8 - 8], rtop
		rwork rtop mov, _,
		49 ` 89 ` 4c ` c0 ` 08 ` _, ret,

:: locals( code 						\ 			pop rwork; push r8; pop rwork; lea r8, [rsp + 8]
		rwork pop, r8 push, rwork push, ret,
:: -locals- code						\ ( # -- )		lea        r8, [rsp + 0x10]
		4c ` 8d ` 44 ` 24 ` 00 ` ret,
		
:: )locals code
		rwork pop, r8 pop, rwork push, ret,

: :local@ [compile] literal compile #l@ ;
: :local! [compile] literal compile #l! ;

: local0@ 0 :local@ ; immediate
: local1@ 1 :local@ ; immediate
: local2@ 2 :local@ ; immediate
: local3@ 3 :local@ ; immediate
: local4@ 4 :local@ ; immediate
: local5@ 5 :local@ ; immediate
: local6@ 6 :local@ ; immediate
: local7@ 7 :local@ ; immediate
: local8@ 8 :local@ ; immediate
: local9@ 9 :local@ ; immediate

: local0! 0 :local! ; immediate
: local1! 1 :local! ; immediate
: local2! 2 :local! ; immediate
: local3! 3 :local! ; immediate
: local4! 4 :local! ; immediate
: local5! 5 :local! ; immediate
: local6! 6 :local! ; immediate
: local7! 7 :local! ; immediate
: local8! 8 :local! ; immediate
: local9! 9 :local! ; immediate

create locals@ 
	' local0@ , ' local1@ , ' local2@ , ' local3@ , ' local4@ ,
	' local5@ , ' local6@ , ' local7@ , ' local8@ , ' local9@ , 0 ,

create locals! 
	' local0! , ' local1! , ' local2! , ' local3! , ' local4! ,
	' local5! , ' local6! , ' local7! , ' local8! , ' local9! , 0 ,

:: #local 0 var

: return
	#local @ for compile r> compile _ over
	compile )locals
; immediate

: move		\ ( s d # -- )	Move cells
	for
		{ | @ >< cell+ >< } 	\ s+1 v d
		| { ! } cell+		\ s+1 d+1
	over _
;
: (	\ ( "name"... ) Define locals
	0 #local !
	begin bl word count | 0 = break
		>< | c@ [char] ) = break
		1- >< ||{{
		locals@ #local @ cells + @
		| 0 = if abort" Out of locals" then
		>name
		>< cell/ 1+ move _
		}}
		|| >< | c@ 1+ >< c! _ ||
		+ 1+ [char] ! >< c! 
		1+ cell/ 1+
		locals! #local @ cells + @
		>name >< move _

		#local @ 1+ #local !
	again then then _ _ 
	\ Zap old local names to avoid surprises (don't ask)
	#local @
	begin
		locals@ #local @ cells + @
		| 0 = break
		>name 0 >< c!
		locals! #local @ cells + @
		>name 0 >< c!
		#local @ 1+ #local !
	again
	then
	_
	| #local !
	| if
		compile locals(
		for compile >r over 
		compile -locals-
	else _ then
; immediate
\ Zap all locals names so that they are not used as is
( )


								\\ Testing framework
: (TEST)	1 testing !  1 test-result ! empty-stack
		guard ;
: (.TEST)	norm 1b emit 5b emit 35 emit 30 emit 47 emit ;
: TEST"		compile cr compile blue [compile] ." compile (.TEST)
		compile (TEST) ; immediate
: test-expected ( :expected )
		1b emit 5b emit 35 emit 30 emit 47 emit
		0 testing !
		test-result @ | :expected = if
			green	if ." SUCCEEDED expectedly " else ." FAILED    expectedly " then
		else
			red	if ." SUCCEEDED unexpectedly " else ." FAILED    unexpectedly " then
		then	norm cr
		empty-stack
		return ;
: ?SUCCEEDED	1 test-expected ;
: ?FAILED	0 test-expected ;

								\\ Stack									_stack
								\ Structure: pointer limit data...
: stack    0 , | , cells allot does> ;				\ ( n -- ) ( -- stack )	Stack N cells size
: empty    0 >< ! ;						\ ( stack -- )		Empty stack
: stack@   | @ >| cell+ @ ;					\ ( stack -- stack pointer limit )	Extracts stack parameters onto data stack
: .stack   | @ | if >< cell+ cell+ >< for | @ . cell+ over _	\ ( stack -- )
           else _ _ then ;

: >s       | @ >| cell+ @					\ ( a stack -- | E )    Pushes element onto stack or aborts on overflow
	   >| - if						\ ( a stack sp limit )	Check if stack about to overflow
	   >|>| 1+ >< !						\ ( a stack sp )	Increment stack pointer
           cells + cell+ cell+ !				\ ( a stack sp )	Store element
	   else _ >name count type bl emit
	   0add bad57ac .abort then ;				\ 			Stack overflow

: s>       | @ | if						\ ( stack -- a | E )	Pops element off stack or aborts on underflow
           1- >|>| >< !						\ ( stack sp )		Decrement stack pointer
           cells + cell+ cell+ @				\ ( stack sp )		Fetch element
	   else _ >name count type bl emit
	   05bb bad57ac .abort then ;				\			Stack underflow

: #|>>s     >< | { | | if for | { I - 1+ #| >| >s } over _	\ ( an ... a1 n s -- a1 ... an n ) ( s: an ... a1 n )
           else _ _ then } | <<< >< >s  ;			\ Direct upload of N elements from data stack onto the specified stack

: #->>s >< | { | if for | I 1+ #| >< >s over			\ ( an ... a1 n s -- an ... a1 n )
           else _ then } | <<< >< >s  ;				\ Reverse upload of N elements from data stack onto the specified stack

: s#>>     | s> | { | if for | s> >< over _ else _ _ then } ;	\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Download N elements off the specified stack onto the data stack

								\\ Structures

: struct   create 				                \ ( "<name>" -- xt )	Structure is a vocabulary, also holding previous context and size
           here current @ | , , 0 , 0 ,				\ 			latest, parent, size, packed,
	   latest context !
           does> context ! ;

: packed   1 context @ cell+ cell+ cell+ ! ;			\ ( -- )		Marks structure as packed

: field	   >< | current ! create				\ ( a field-size -- )	Defines a field in current structure (sets context to strucuture vocabulary)
           | cell+ cell+ | cell+ @ >< | { @ ><
	   if else >>| >2^ #aligned then
	   | ,  >>> | , + } !
	   does> | @ >< cell+ @ ;				\ ( a -- a' size )	Returns address relative to structure start and field size

: ;struct  _ current @ cell+ @ context ! definitions ;		\ ( a -- ) 		Restores context to the parent vocabulary

: #struct  context @ cell+ cell+ @ ;				\ ( a -- # )		Returns structure size

: struct:  create context @ , here context @ cell+ cell+ @ 
           | allot
           0 fill
           does> | @ context ! cell+ ;

: #@       \ ( a # -- v )
	   | 1 = if _ c@ else
	   | 2 = if _ 2@ else
	   | 3 = if _ | 2@ >< 2 + c@ 10 shl + else
	   | 4 = if _ 4@ else
	   | 5 = if _ | 4@ >< 4 + c@ 20 shl + else
	   | 6 = if _ | 4@ >< 4 + 2@ 20 shl + else
	   | 7 = if _ | 4@ >< 4 + | { 2@ 20 shl + } 1+ c@ 30 shl + else
	   | 8 = if _ @ else bad515e01 574c7 .abort
	   then then then then then then then then ;
         
: #!       \ ( v a # -- )
	   | 1 = if _ c! else
	   | 2 = if _ 2! else
	   | 3 = if _ >|>| 2! >< 10 sar >< 2 + c! else
	   | 4 = if _ 4! else
	   | 5 = if _ >|>| 4! >< 20 sar >< 4 + c! else
	   | 6 = if _ >|>| 4! >< 20 sar >< 4 + 2! else
	   | 7 = if _ >|>| 4! >< 20 sar >< 4 + >|>| 2! >< 30 sar >< 1+ c! else
	   | 8 = if _ ! else .. bad515e01 574c7 .abort
	   then then then then then then then then ;
: .@       { >| + } #@ >< ;
: .!       { >>| + } #! ;

