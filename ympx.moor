								\\ VGA display

\ VGA test buffer
1000 aligned
:: 'vga	adr 1000 allot 'vga 1000 0 fill				\ Arena contains logical objects
: vga	baremetal? if 0b8000 else 'vga then ;
\ VGA positioning
: line	a0 * + ;
: col	1 shl + ;

\ Number display
: nibble	0f and ;
: >nibble	4 sar ;
: nibble>char	| 0a >= if [char] A [char] 9 - 1- + then [char] 0 + ;
: .n								\ ( a color nibble -- a-2 ) 
	0f and nibble>char
	{ 8 shl } or
	>< |{ 2! } 2 + ;
: .b	||{{  4 sar .n } } .n ;					\ ( a color byte -- )
: .w	||{{  8 sar .b } } .b ;					\ ( a color word -- )
: .d	||{{ 10 sar .w } } .w ;					\ ( a color qword -- )
: .q	||{{ 20 sar .d } } .d ;					\ ( a color dword -- )
: .c	{ 8 shl } or >< | { 2! } 2 + ;				\ ( a color char -- a+2 )	Display character
: .bl	20 .c ;							\ ( a color -- a+2 )	 	Display blank character
: .c'	c@ .c ;							\ ( a color 'c -- a+2 )		Fetch and display character
: .t count for ||{{ .c' }} 1+ over _ _ ;			\ ( a color 'c u -- a+2*u )	Display string

\ Page allocation

: page								\ ( "<name>" -- )		Creates page-aligned zero-filled buffer
	here 1000 aligned here! here 1000 allot 
	:: val
	latest execute 1000 0 fill ;

\ Scratch playground for code generation
:: scratch code
page 'scratch

INTERPRETING ' scratch behavior 				\ Scratch code points to 4K aligned scratch area
>< _ 'scratch ><
INTERPRETING ' scratch does

: <scratch here 'scratch here! ;
: scratch> ret, here! ;

: asm( <scratch ;
: )asm scratch> scratch ;


: .scratch	'scratch 40 dump ;

\ Register display
: reg@	 |, rtop >< mov, ;

: .regname							\ ( a color r -- a+2 )
	" AXCXBXDXSPBPSIDIR8 9101112131415" 1+ >< 2* + 
	| c@ >< { >| { .c } }  1+ c@ .c ;
: .regs 10 
	for	vga I 1- line 3e col      
		30  I 1- .regname 
		2f  asm( I 1- reg@ )asm .q _
	over ;

\\ CR and MSR

: cr0	asm( |, 0f ` 20 ` c1 ` )asm ;
: cr3	asm( |, 0f ` 20 ` d9 ` )asm ;
: cr4	asm( |, 0f ` 20 ` e1 ` )asm ;

: cr0!	asm( 0f ` 22 ` c1 ` _, )asm ;
: cr3!	asm( 0f ` 22 ` d9 ` _, )asm ;
: cr4!	asm( 0f ` 22 ` e1 ` _, )asm ;

: msr	20 >< asm( 0f ` 32 ` _, rdx shl, rax rdx or, r0 rax mov, )asm   ;
: msr!  asm( rcx push, _,  rdx rdx xor, rax rcx mov, rcx pop,  0f ` 30 ` _, )asm ;

\ MSRs
c0000080 :: EFER val	0000003a :: FCTL val	0000048b :: CTL2 val	00000480 :: VBAS val
00000486 :: VM0S val	00000487 :: VM0R val	00000488 :: VM4S val	00000489 :: VM4R val	

\ CR0 fields
80000000 :: PG val	00040000 :: AM val	00010000 :: WP val	00000001 :: PE val
\ CR4 fields
00002000 :: VMXE val	00100000 :: SMEP val	00200000 :: SMAP val	00800000 :: CET val
00400000 :: PKE val	01000000 :: PKS val     00000020 :: PAE	val	00020000 :: PCIDE val
\ EFER fields
00000001 :: SCE val	00000100 :: LME val	00000400 :: LMA val	00000000 :: NXE val
\ FCTL fields
00100000 :: LMCE val	00000001 :: VME val	00000002 :: VMSXE val	00000004 :: VMNSXE val

: .cregs
	vga 0 line 1c col 3f " VM0S " .t  2f VM0S msr .d _
	vga 1 line 1c col 3f " VM0R " .t  2f VM0R msr .d _
	vga 2 line 1c col 3f " CR0  " .t  2f cr0 | { .d _ }
	| { PG and if vga 3 line 1c col 30 " PG" .t 30 .bl _ then }
	| { AM and if vga 3 line 1f col 30 " AM" .t 30 .bl _ then }
	| { WP and if vga 3 line 22 col 30 " WP" .t 30 .bl _ then }
	| { PE and if vga 3 line 25 col 30 " PE" .t 30 .bl _ then }
	_
	vga 4 line 1c col 3f " VM4S " .t  2f VM4S msr .d _
	vga 5 line 1c col 3f " VM4R " .t  2f VM4R msr .d _
	vga 6 line 1c col 3f " CR4  " .t  2f cr4 | { .d _ }
	| { PAE   and if vga 7 line 1c col 30 " PAE"   .t 30 .bl _ then }
	| { VMXE  and if vga 7 line 20 col 30 " VMXE"  .t 30 .bl _ then }
	_
	vga 8 line 1c col 3f " EFER " .t  2f EFER msr  | { .d _ }
	| { LME  and if vga 9 line 1c col 30 " LME"  .t 30 .bl _ then }
	| { LMA  and if vga 9 line 20 col 30 " LMA"  .t 30 .bl _ then }
	| { NXE  and if vga 9 line 24 col 30 " NXE"  .t 30 .bl _ then }
	_
	vga a line 1c col 3f " CTL2 " .t  2f CTL2 msr | { .d _ }
	_
	vga b line 1c col 3f " FCTL " .t  2f FCTL msr | { .d _ }
	\ | { LMCE    and if vga 9 line 1c col 30 " LMCE"  .t 30 .bl then _ }
	| { VME     and if vga c line 1c col 30 " VME"  .t 30 .bl _ then }
	| { VMNSXE  and if vga c line 20 col 30 " VMNSXE"  .t 30 .bl _ then }
	| { VMSXE   and if vga c line 26 col 30 " VMSXE"  .t 30 .bl _ then }
	_
	vga d line 1c col 3f " VBAS " .t  2f VBAS msr | { .q _ }
	_
	;
\\ VM 
: vmres,	setc, xchg01, setz, |, r0 rdx mov, ;	\ ( -- 0 0 success |  0 1 -- fail invalid | 1 0 -- fail valid )

: vmxon 	asm( 67 ` f3 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmclear 	asm( 66 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmptrld 	asm( 0f ` c7 ` 31 ` vmres, )asm ;
: vmxoff	asm( 0f ` 01 ` c4 ` )asm ;
: vmlaunch	asm( 0f ` 01 ` c2 ` vmres, )asm ;
: vmresume	asm( 0f ` 01 ` c3 ` )asm ;

: vmread	asm(  0f ` 78 ` c8 ` vmres,			\ ( vm-field -- value ZF CF )		Reads field from current VMCS
		|, r0 rax mov, )asm <<< ;
: vmwrite	<<< asm( rax r0 mov, _,		\ ( value vm-field -- value ZF CF )	Writes field to current VMCS
		0f ` 79 ` c1 ` vmres,	
		)asm -1 <<< ;

: high		1 ;
: full		;

: control 	;
: vmexit	[ 1 a shl ] literal or ;
: guest		[ 2 a shl ] literal or ;
: host		[ 3 a shl ] literal or ;

: 16bit		;
: 32bit		[ 2 d shl ] literal or ;
: 64bit		[ 1 d shl ] literal or ;
: natural	[ 3 d shl ] literal or ;

0	full 32bit vmexit 	:: vminst_error val


: ?VmReadWrite							\ ( field value ZF CF name -- ) 
	<<< -if -if _ >< _ else
		white count type bl emit yellow ." faulted, field " blue _ . norm cr
		8470cafe 600df00d4 .abort then
	else _ white count type bl emit red ." failed, field " blue _ . norm cr
		8470cafe badf00d4 .abort
	then ;

: try ' | compile | compile, >name [compile] literal compile ?VmReadWrite ; immediate

: VmRead	try vmread ;
: VmWrite	try vmwrite _ ;


: ?VmxRes							\ ( ZF CF name -- 0=sucesss | 1=fail )
	<<< -if -if _ else
		white count type bl emit yellow ." faulted, result "
		vminst_error VmRead blue . norm cr
		8470cafe 600df00d .abort then
	else _ red count type bl emit " failed" cr
		8470cafe badf00d .abort
	then ;

: try
	' | compile, >name [compile] literal compile ?VmxRes ; immediate

\\ Launch

\ VMCS and the first and one and only VM
page vmcs
vmcs :: 'vmcs var

page vm1
vm1 :: 'vm1 var

\ Entering VMX root operation
: VmxOn
	cr4 VMXE or cr4! 
	cr0 VM0S msr or VM0R msr and cr0!
	cr4 VM4S msr or VM4R msr and cr4!
	VBAS msr vmcs 4!

	'vmcs try vmxon
;
: VmInit
	VBAS msr vm1 4!

	'vm1 try vmclear
	'vm1 try vmptrld
	'vm1 try vmlaunch
;
: VmRun
	VmxOn 
	VmInit 
;

