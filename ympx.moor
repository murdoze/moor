								\\ VGA display

\ VGA test buffer
1000 aligned
:: 'vga	adr 1000 allot 'vga 1000 0 fill				\ Arena contains logical objects
: vga	baremetal? if 0b8000 else 'vga then ;
\ VGA positioning
: line	a0 * + ;
: col	1 shl + ;

\ Number display
: nibble	0f and ;
: >nibble	4 sar ;
: nibble>char	| 0a >= if [char] A [char] 9 - 1- + then [char] 0 + ;
: .n						\ ( a color nibble -- a-2 ) 
	0f and nibble>char
	{ 8 shl } or
	>< |{ 2! } 2 + ;
: .b	||{{  4 sar .n } } .n ;			\ ( a color byte -- )
: .w	||{{  8 sar .b } } .b ;			\ ( a color word -- )
: .d	||{{ 10 sar .w } } .w ;			\ ( a color qword -- )
: .q	||{{ 20 sar .d } } .d ;			\ ( a color dword -- )
: .c	{ 8 shl } or >< | { 2! } 2 + ;		\ ( a color char -- a+2 )	Display character
: .bl	20 .c ;					\ ( a color -- a+2 )	 	Display blank character
: .c'	c@ .c ;					\ ( a color 'c -- a+2 )		Fetch and display character
: .t count for ||{{ .c' }} 1+ over _ _ ;	\ ( a color 'c u -- a+2*u )	Display string

\ Scratch playground for code generation
cr .( Scratch ) cold
:: scratch code INTERPRETING ' scratch behavior cr .S _ _ 
here 1000 aligned here! 
here 1000 allot :: 'scratch val cr 'scratch .
INTERPRETING ' scratch behavior cr .( A) .S 
>r cr .( B)  .S  _ 'scratch cr .( C) .S  r> cr .( D)  .S
INTERPRETING ' scratch cr .S   does
INTERPRETING ' scratch behavior cr .S
cr .( --------------------------------------- )
'scratch 1000 0 fill


: <scratch here 'scratch here! ;
: scratch> ret, here! ;

: asm( 11 ..	<scratch ;
: )asm 22 ..	scratch> 33 .. scratch 44 .. ;

\ Register display
: reg@	 |, rtop >< mov, ;

: .regname					\ ( a color r -- a+2 )
	" AXCXBXDXSPBPSIDIR8R9101112131415" 1+ >< 2* + 
	| c@ >< { >| { .c } }  1+ c@ .c ;
: .regs 10 
	for	vga I 1- line 30 col      
		30  I 1- .regname 
		2f  asm( I 1- reg@ )asm .q 
	over ;

: cr0	asm( |, 0f ` 20 ` c1 ` )asm ;
: cr4	asm( |, 0f ` 20 ` e1 ` )asm ;
: cr3	asm( |, 0f ` 20 ` d9 ` )asm ;

: rdmsr	asm( 0f ` 32 ` )asm ;
: wrmsr asm( 0f ` 30 ` )asm ;

\ MSRs
c0000080 :: EFER val	0000003a :: FCTRL val	0000048b :: PCTLS2 val	
00000486 :: VMXF0 val	00000487 :: VMXF1 val	00000488 :: VMXF3 val	00000489 :: VMXF3 val	

\ CR0 fields
80000000 :: PG val	00040000 :: AM val	00010000 :: WP val	00000001 :: PE val
\ CR4 fields
00002000 :: VMXE val	00100000 :: SMEP val	00200000 :: SMAP val	00800000 :: CET val
00400000 :: PKE val	01000000 :: PKS val     00000020 :: PAE	val	00020000 :: PCIDE val
\ EFER fields
00000001 :: SCE val	00000000 :: LME val	00000000 :: LMA val	00000000 :: NXE val

: .cregs
	vga 0 line 1c col 30 " CR3" .t  1f asm( |, 0f ` 20 ` d9 ` )asm .d
	vga 1 line 1c col 30 " CR0" .t  2f cr0 | { .d _ }
	| { PG and if vga 2 line 1c col 30 " PG" .t 30 .bl then _ }
	| { AM and if vga 2 line 1f col 30 " AM" .t 30 .bl then _ }
	| { WP and if vga 2 line 22 col 30 " WP" .t 30 .bl then _ }
	| { PE and if vga 2 line 25 col 30 " PE" .t 30 .bl then _ }
	_
	vga 3 line 1c col 30 " CR4" .t  2f cr4 | { .d _ }
	| { PAE   and if vga 4 line 1c col 30 " PAE"   .t 30 .bl then _ }
	| { VMXE  and if vga 5 line 1c col 30 " VMXE"  .t 30 .bl then _ }
	_
	;

: .msreg ;

\ Tests

.( vga = ) vga . cr
: ??vga vga @ . .S cr ;

: qn	vga df 09 .n df 0f .n	 		??vga ;
: qb	vga df 9f .b df a1 .b 			??vga ;
: qw	vga df 1234 .w	df .bl df 5678 .w 	??vga ;
: qd	vga df 12345678 .d 			??vga ;
: qd1	vga df 12345678 .d df .bl df .bl df 90abcdef .d  ??vga ;
: qq	vga df 1234567890abcdef .q 		??vga ;

: qt	vga df " 1234" count .t			??vga ; 
: qtt	vga cf " Stack overflow" count .t			??vga ; 






