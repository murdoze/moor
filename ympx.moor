								\\ VGA display

\ VGA test buffer
1000 aligned
:: 'vga	adr 1000 allot 'vga 1000 0 fill				\ Arena contains logical objects
: vga	baremetal? if 0b8000 else 'vga then ;
\ VGA positioning
: line	a0 * + ;
: col	1 shl + ;

\ Number display
: nibble	0f and ;
: >nibble	4 sar ;
: nibble>char	| 0a >= if [char] A [char] 9 - 1- + then [char] 0 + ;
: .n								\ ( a color nibble -- a-2 ) 
	0f and nibble>char
	{ 8 shl } or
	>< |{ 2! } 2 + ;
: .b	||{{  4 sar .n } } .n ;					\ ( a color byte -- )
: .w	||{{  8 sar .b } } .b ;					\ ( a color word -- )
: .d	||{{ 10 sar .w } } .w ;					\ ( a color qword -- )
: .q	||{{ 20 sar .d } } .d ;					\ ( a color dword -- )
: .c	{ 8 shl } or >< | { 2! } 2 + ;				\ ( a color char -- a+2 )	Display character
: .bl	20 .c ;							\ ( a color -- a+2 )	 	Display blank character
: .c'	c@ .c ;							\ ( a color 'c -- a+2 )		Fetch and display character
: .t count for ||{{ .c' }} 1+ over _ _ ;			\ ( a color 'c u -- a+2*u )	Display string

\ Page allocation

: page								\ ( "<name>" -- )		Creates page-aligned zero-filled buffer
	here 1000 aligned here! here 1000 allot 
	:: val
	latest execute 1000 0 fill ;

\ Scratch playground for code generation
:: scratch code
page 'scratch

INTERPRETING ' scratch behavior 				\ Scratch code points to 4K aligned scratch area
>< _ 'scratch ><
INTERPRETING ' scratch does

: <scratch here 'scratch here! ;
: scratch> ret, here! ;

: asm( <scratch ;
: )asm scratch> scratch ;


: .scratch	'scratch 40 dump ;

\\ CR and MSR

: cr0	asm( |, 0f ` 20 ` c1 ` )asm ;
: cr3	asm( |, 0f ` 20 ` d9 ` )asm ;
: cr4	asm( |, 0f ` 20 ` e1 ` )asm ;

: cr0!	asm( 0f ` 22 ` c1 ` _, )asm ;
: cr3!	asm( 0f ` 22 ` d9 ` _, )asm ;
: cr4!	asm( 0f ` 22 ` e1 ` _, )asm ;

: msr	20 >< asm( 0f ` 32 ` _, rdx shl, rax rdx or, r0 rax mov, )asm   ;
: msr!  asm( rcx push, _,  rdx rdx xor, rax rcx mov, rcx pop,  0f ` 30 ` _, )asm ;

: cs	asm( |, 66 ` 8c ` c9 ` )asm ;
: ds	asm( |, 66 ` 8c ` d9 ` )asm ;

\ MSRs and Control Registers {{{1
\ MSRs
c0000080 :: EFER val	
c0000081 :: STAR val
c0000082 :: LSTAR val
c0000083 :: CSTAR val
c0000083 :: FMASK val
c0000100 :: FS_BASE val
c0000101 :: GS_BASE val
c0000102 :: KERNEL_GS_BASE val
c0000103 :: TSC_AUX val

0000003a :: FCTL val	0000048b :: CTL2 val	00000480 :: VBAS val
00000486 :: VM0S val	00000487 :: VM0R val	00000488 :: VM4S val	00000489 :: VM4R val	


\ CR0 fields
80000000 :: PG val	00040000 :: AM val	00010000 :: WP val	00000001 :: PE val
\ CR4 fields
00002000 :: VMXE val	00100000 :: SMEP val	00200000 :: SMAP val	00800000 :: CET val
00400000 :: PKE val	01000000 :: PKS val     00000020 :: PAE	val	00020000 :: PCIDE val
\ EFER fields
00000001 :: SCE val	00000100 :: LME val	00000400 :: LMA val	00000000 :: NXE val
\ FCTL fields
00100000 :: LMCE val	00000001 :: VME val	00000002 :: VMSXE val	00000004 :: VMNSXE val
\ }}}

\ Register display {{{1
: reg@	 |, rtop >< mov, ;

: .regname							\ ( a color r -- a+2 )
	" AXCXBXDXSPBPSIDIR8 9101112131415" 1+ >< 2* + 
	| c@ >< { >| { .c } }  1+ c@ .c ;
: .regs 10 
	for	vga I 1- line 3e col      
		30  I 1- .regname 
		2f  asm( I 1- reg@ )asm .q _
	over ;

: .cregs
	vga 0 line 1c col 3f " VM0S " .t  2f VM0S msr .d _
	vga 1 line 1c col 3f " VM0R " .t  2f VM0R msr .d _
	vga 2 line 1c col 3f " CR0  " .t  2f cr0 | { .d _ }
	| { PG and if vga 3 line 1c col 30 " PG" .t 30 .bl _ then }
	| { AM and if vga 3 line 1f col 30 " AM" .t 30 .bl _ then }
	| { WP and if vga 3 line 22 col 30 " WP" .t 30 .bl _ then }
	| { PE and if vga 3 line 25 col 30 " PE" .t 30 .bl _ then }
	_
	vga 4 line 1c col 3f " VM4S " .t  2f VM4S msr .d _
	vga 5 line 1c col 3f " VM4R " .t  2f VM4R msr .d _
	vga 6 line 1c col 3f " CR4  " .t  2f cr4 | { .d _ }
	| { PAE   and if vga 7 line 1c col 30 " PAE"   .t 30 .bl _ then }
	| { VMXE  and if vga 7 line 20 col 30 " VMXE"  .t 30 .bl _ then }
	_
	vga 8 line 1c col 3f " EFER " .t  2f EFER msr  | { .d _ }
	| { LME  and if vga 9 line 1c col 30 " LME"  .t 30 .bl _ then }
	| { LMA  and if vga 9 line 20 col 30 " LMA"  .t 30 .bl _ then }
	| { NXE  and if vga 9 line 24 col 30 " NXE"  .t 30 .bl _ then }
	_
	vga a line 1c col 3f " CTL2 " .t  2f CTL2 msr | { .d _ }
	_
	vga b line 1c col 3f " FCTL " .t  2f FCTL msr | { .d _ }
	\ | { LMCE    and if vga 9 line 1c col 30 " LMCE"  .t 30 .bl then _ }
	| { VME     and if vga c line 1c col 30 " VME"  .t 30 .bl _ then }
	| { VMNSXE  and if vga c line 20 col 30 " VMNSXE"  .t 30 .bl _ then }
	| { VMSXE   and if vga c line 26 col 30 " VMSXE"  .t 30 .bl _ then }
	_
	vga d line 1c col 3f " VBAS " .t  2f VBAS msr | { .q _ }
	_
	;
\ }}}

\\ VM 
\ Instructions
: vmres,	setc, xchg01, setz, |, r0 rdx mov, ;	\ ( -- 0 0 success |  0 1 -- fail invalid | 1 0 -- fail valid )

: vmxon 	asm( 67 ` f3 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmclear 	asm( 66 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmptrld 	asm( 0f ` c7 ` 31 ` vmres, )asm ;
: vmxoff	asm( 0f ` 01 ` c4 ` )asm ;
: vmlaunch	asm( 0f ` 01 ` c2 ` vmres, )asm ;
: vmresume	asm( 0f ` 01 ` c3 ` )asm ;

: vmread	asm(  0f ` 78 ` c8 ` vmres,			\ ( vm-field -- value ZF CF )		Reads field from current VMCS
		|, r0 rax mov, )asm <<< ;
: vmwrite	<<< asm( rax r0 mov, _,				\ ( value vm-field -- value ZF CF )	Writes field to current VMCS
		0f ` 79 ` c1 ` vmres,	
		)asm -1 <<< ;

\ VMCS fields
: bits		shl ;
: bit		1 >< shl ;
: set?		and ;
: set		or ;
: reset		not and ;

: high		2* 1 or ;
: full		2* ;

: control 	;
: vmexit	1 #10 bits set ;
: guest		2 #10 bits set ;
: host		3 #10 bits set ;

: 16bit		;
: 32bit		2 #13 bits set ;
: 64bit		1 #13 bits set ;
: natural	3 #12 bits set ;


0	full 32bit vmexit 	:: vminstruction_error val


3	full 64bit control	:: vmexit_msr_store_addr val
7	full 32bit control	:: vmexit_msr_store_count val

4	full 64bit control	:: vmexit_msr_load_addr val
8	full 32bit control	:: vmexit_msr_load_count val

5	full 64bit control	:: vmentry_msr_load_addr val
10	full 32bit control	:: vmentry_msr_load_count val

6	full 32bit control	:: primary_exit_ctl val

0	full 32bit control	:: pin_exec_ctrl val
1	full 32bit control	:: proc_exec_ctrl val

: ?VmReadWrite							\ ( field value ZF CF name -- )  {{{
	<<< -if -if _ >< _ else
		white count type bl emit yellow ." faulted, field " blue _ . norm cr
		8470cafe 600df00d4 .abort then
	else _ white count type bl emit red ." failed, field " blue _ . norm cr
		8470cafe badf00d4 .abort
	then ;
\ }}}
: try								|| cr yellow . blue .  
	' | compile | compile, >name 				| count type 
	[compile] literal compile ?VmReadWrite ; immediate

: VmRead	try vmread ;
: VmWrite	try vmwrite _ ;


: ?VmxRes							\ ( ZF CF name -- 0=sucesss | 1=fail ) {{{
	<<< -if -if _ else
		white count type bl emit yellow ." faulted, result "
		vminstruction_error VmRead blue . norm cr
		8470cafe 600df00d1 .abort then
	else _ red count type bl emit " failed" cr
		8470cafe badf00d1 .abort
	then ;
\ }}}
: try
	' | compile, >name [compile] literal compile ?VmxRes ; immediate

\\ Launch

\ VMCS
page vmcs
vmcs :: 'vmcs var

\ VM
page vm1
vm1 :: 'vm1 var

\ Host and guest MSRs {{{1
:: host_msrs adr
EFER 	| , msr ,
STAR 	| , msr ,
LSTAR 	| , msr ,
CSTAR  	| , msr ,
FMASK 	| , msr ,
FS_BASE | , msr ,
GS_BASE | , msr ,
KERNEL_GS_BASE | , msr ,
TSC_AUX | , msr ,
here host_msrs - 8/ 2/ :: #host_msrs val

:: guest_msrs adr
EFER 	, 0 ,
STAR 	, 0 ,	
LSTAR 	, 0 ,
CSTAR 	, 0 ,
FMASK 	, 0 ,
FS_BASE	, 0 ,
GS_BASE	, 0 ,
KERNEL_GS_BASE , 0 ,
TSC_AUX	, 0 ,
here guest_msrs - 8/ 2/ :: #guest_msrs val

: VmWriteMsr
	host_msrs	vmexit_msr_load_addr  	VmWrite
	#host_msrs	vmexit_msr_load_count 	VmWrite

	guest_msrs	vmexit_msr_store_addr 	VmWrite
	#guest_msrs	vmexit_msr_store_count 	VmWrite

	guest_msrs	vmentry_msr_load_addr	VmWrite
	#guest_msrs	vmentry_msr_load_count	VmWrite
;
\ }}}

\ Entering VMX root operation
: VmxOn
	cr4 VMXE or cr4! 
	cr0 VM0S msr or VM0R msr and cr0!
	cr4 VM4S msr or VM4R msr and cr4!
	VBAS msr vmcs 4!

	'vmcs try vmxon
;

: VmInit
	VBAS msr vm1 4!

	'vm1 try vmclear
	'vm1 try vmptrld
	'vm1 try vmlaunch
;

: VmCtrls
	0 
	{ VBAS msr #55 bit set? if 048d else 0481 then msr | 20 sar not } and or
	0 full 32bit control VmWrite \ pin_exec_ctrl

	0 #31 bit reset						\ Table 26-6:	no secondary controls
	{ VBAS msr #55 bit set? if 048e else 0482 then msr | 20 sar not } and or
	1 full 32bit control VmWrite \ proc_exec_ctrl

	0  #9 bit set  #21 bit set				\ Table 26-14:	64-bit host, load EFER
	{ VBAS msr #55 bit set? if 048f else 0483 then msr | 20 sar not } and or
	6 full 32bit control VmWrite \ primary_exit_ctrl
;

: VmRun
	VmxOn 
	VmInit
;

