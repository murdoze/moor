								\\ VGA display

\ VGA test buffer
1000 aligned
:: 'vga	adr 1000 allot 'vga 1000 0 fill				\ Arena contains logical objects
: vga	baremetal? if 0b8000 else 'vga then ;
\ VGA positioning
: line	a0 * + ;
: col	1 shl + ;

\ Number display
: nibble	0f and ;
: >nibble	4 sar ;
: nibble>char	| 0a >= if [char] A [char] 9 - 1- + then [char] 0 + ;
: .n								\ ( a color nibble -- a-2 ) 
	0f and nibble>char
	{ 8 shl } or
	>< |{ 2! } 2 + ;
: .b	||{{  4 sar .n } } .n ;					\ ( a color byte -- )
: .w	||{{  8 sar .b } } .b ;					\ ( a color word -- )
: .d	||{{ 10 sar .w } } .w ;					\ ( a color qword -- )
: .q	||{{ 20 sar .d } } .d ;					\ ( a color dword -- )
: .c	{ 8 shl } or >< | { 2! } 2 + ;				\ ( a color char -- a+2 )	Display character
: .bl	20 .c ;							\ ( a color -- a+2 )	 	Display blank character
: .c'	c@ .c ;							\ ( a color 'c -- a+2 )		Fetch and display character
: .t count for ||{{ .c' }} 1+ over _ _ ;			\ ( a color 'c u -- a+2*u )	Display string

\ Page allocation

: page								\ ( "<name>" -- )		Creates page-aligned zero-filled buffer
	here 1000 aligned here! here 1000 allot 
	:: val
	latest execute 1000 0 fill ;

\ Scratch playground for code generation
:: scratch code
page 'scratch

INTERPRETING ' scratch behavior 				\ Scratch code points to 4K aligned scratch area
>< _ 'scratch ><
INTERPRETING ' scratch does

: <scratch here 'scratch here! ;
: scratch> ret, here! ;

: asm( <scratch ;
: )asm scratch> scratch ;


: .scratch	'scratch 40 dump ;

\\ CR and MSR

: cr0	asm( |, 0f ` 20 ` c1 ` )asm ;
: cr3	asm( |, 0f ` 20 ` d9 ` )asm ;
: cr4	asm( |, 0f ` 20 ` e1 ` )asm ;

: cr0!	asm( 0f ` 22 ` c1 ` _, )asm ;
: cr3!	asm( 0f ` 22 ` d9 ` _, )asm ;
: cr4!	asm( 0f ` 22 ` e1 ` _, )asm ;

: msr	20 >< asm( 0f ` 32 ` _, rdx shl, rax rdx or, r0 rax mov, )asm   ;
: msr!  asm( rcx push, _,  rdx rdx xor, rax rcx mov, rcx pop,  0f ` 30 ` _, )asm ;

: cs	asm( |, r0 r0 xor, 66 ` 8c ` c9 ` )asm ;
: ds	asm( |, 66 ` 8c ` d9 ` )asm ;

:: dt adr 0 2, 0 ,
: dt@ dt 2@ dt 2 + @ ;
: gdt@	dt asm( 0f ` 01 ` 01 ` )asm dt@ ;		\ ( -- seg base ) Returns GDTR
: idt@	dt asm( 0f ` 01 ` 09 ` )asm dt@ ;		\ ( -- seg base ) Returns IDTR
: tr@   dt asm( 67 ` 0f ` 00 ` 09 ` )asm dt@ ;		\ ( -- seg base ) Returns TR

\ MSRs and Control Registers {{{1
\ MSRs
c0000080 :: EFER val	
c0000081 :: STAR val
c0000082 :: LSTAR val
c0000083 :: CSTAR val
c0000083 :: FMASK val
c0000100 :: FS_BASE val
c0000101 :: GS_BASE val
c0000102 :: KERNEL_GS_BASE val
c0000103 :: TSC_AUX val

0000003a :: FCTL val	0000048b :: CTL2 val	00000480 :: VBAS val
00000486 :: VM0S val	00000487 :: VM0R val	00000488 :: VM4S val	00000489 :: VM4R val	


\ CR0 fields
80000000 :: PG val	00040000 :: AM val	00010000 :: WP val	00000001 :: PE val
\ CR4 fields
00002000 :: VMXE val	00100000 :: SMEP val	00200000 :: SMAP val	00800000 :: CET val
00400000 :: PKE val	01000000 :: PKS val     00000020 :: PAE	val	00020000 :: PCIDE val
\ EFER fields
00000001 :: SCE val	00000100 :: LME val	00000400 :: LMA val	00000000 :: NXE val
\ FCTL fields
00100000 :: LMCE val	00000001 :: VME val	00000002 :: VMSXE val	00000004 :: VMNSXE val
\ }}}

\ Register display {{{1
: reg@	 |, rtop >< mov, ;

: .regname							\ ( a color r -- a+2 )
	" AXCXBXDXSPBPSIDIR8 9101112131415" 1+ >< 2* + 
	| c@ >< { >| { .c } }  1+ c@ .c ;
: .regs 10 
	for	vga I 1- line 3e col      
		30  I 1- .regname 
		2f  asm( I 1- reg@ )asm .q _
	over ;

: .cregs
	vga 0 line 1c col 3f " VM0S " .t  2f VM0S msr .d _
	vga 1 line 1c col 3f " VM0R " .t  2f VM0R msr .d _
	vga 2 line 1c col 3f " CR0  " .t  2f cr0 | { .d _ }
	| { PG and if vga 3 line 1c col 30 " PG" .t 30 .bl _ then }
	| { AM and if vga 3 line 1f col 30 " AM" .t 30 .bl _ then }
	| { WP and if vga 3 line 22 col 30 " WP" .t 30 .bl _ then }
	| { PE and if vga 3 line 25 col 30 " PE" .t 30 .bl _ then }
	_
	vga 4 line 1c col 3f " VM4S " .t  2f VM4S msr .d _
	vga 5 line 1c col 3f " VM4R " .t  2f VM4R msr .d _
	vga 6 line 1c col 3f " CR4  " .t  2f cr4 | { .d _ }
	| { PAE   and if vga 7 line 1c col 30 " PAE"   .t 30 .bl _ then }
	| { VMXE  and if vga 7 line 20 col 30 " VMXE"  .t 30 .bl _ then }
	_
	vga 8 line 1c col 3f " EFER " .t  2f EFER msr  | { .d _ }
	| { LME  and if vga 9 line 1c col 30 " LME"  .t 30 .bl _ then }
	| { LMA  and if vga 9 line 20 col 30 " LMA"  .t 30 .bl _ then }
	| { NXE  and if vga 9 line 24 col 30 " NXE"  .t 30 .bl _ then }
	_
	vga a line 1c col 3f " CTL2 " .t  2f CTL2 msr | { .d _ }
	_
	vga b line 1c col 3f " FCTL " .t  2f FCTL msr | { .d _ }
	\ | { LMCE    and if vga 9 line 1c col 30 " LMCE"  .t 30 .bl then _ }
	| { VME     and if vga c line 1c col 30 " VME"  .t 30 .bl _ then }
	| { VMNSXE  and if vga c line 20 col 30 " VMNSXE"  .t 30 .bl _ then }
	| { VMSXE   and if vga c line 26 col 30 " VMSXE"  .t 30 .bl _ then }
	_
	vga d line 1c col 3f " VBAS " .t  2f VBAS msr | { .q _ }
	_
	;
\ }}}

\\ VM 
\ Instructions
: vmres,	setc, xchg01, setz, |, r0 rdx mov, ;	\ ( -- 0 0 success |  0 1 -- fail invalid | 1 0 -- fail valid )

: vmxon 	asm( 67 ` f3 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmclear 	asm( 66 ` 0f ` c7 ` 31 ` vmres, )asm ;
: vmptrld 	asm( 0f ` c7 ` 31 ` vmres, )asm ;
: vmxoff	asm( 0f ` 01 ` c4 ` )asm ;
: vmlaunch	asm( 0f ` 01 ` c2 ` vmres, )asm ;
: vmresume	asm( 0f ` 01 ` c3 ` vmres, )asm ;

: vmread	asm(  0f ` 78 ` c8 ` vmres,			\ ( vm-field -- value ZF CF )		Reads field from current VMCS
		|, r0 rax mov, )asm <<< ;
: vmwrite	<<< asm( rax r0 mov, _,				\ ( value vm-field -- value ZF CF )	Writes field to current VMCS
		0f ` 79 ` c1 ` vmres,	
		)asm -1 <<< ;

\ VMCS fields
: bits		shl ;
: bit		1 >< shl ;
: set?		and ;
: set		or ;
: reset		not and ;
: 2mask		| 20 sar >< 0fffffff and >< >>> and or ;	\ ( v 64-bit-msr-mask-32-set-32-reset -- masked-v )

: high		2* 1 or ;
: full		2* ;

: control 	;
: vmexit	1 #10 bits set ;
: guest		2 #10 bits set ;
: host		3 #10 bits set ;

: 16bit		;
: 32bit		2 #13 bits set ;
: 64bit		1 #13 bits set ;
: natural	3 #13 bits set ;


0	full 32bit vmexit 	:: vminstruction_error val	\ Table B-9.; Table 32-1. VM-Instruction Error Numbers
1	full 32bit vmexit	:: vmexit_reason val

3	full 64bit control	:: vmexit_msr_store_addr val
7	full 32bit control	:: vmexit_msr_store_count val

4	full 64bit control	:: vmexit_msr_load_addr val
8	full 32bit control	:: vmexit_msr_load_count val

5	full 64bit control	:: vmentry_msr_load_addr val
10	full 32bit control	:: vmentry_msr_load_count val

6	full 32bit control	:: primary_exit_ctl val

0	full 32bit control	:: pin_exec_ctrl val
1	full 32bit control	:: proc_exec_ctrl val

: ?VmReadWrite							\ ( field value ZF CF name -- )  {{{
	<<< -if -if _ >< _ else
		white count type bl emit yellow ." faulted, field " blue _ . norm cr
		8470cafe 600df00d4 .abort then
	else _ white count type bl emit red ." failed, field " blue _ . norm cr
		8470cafe badf00d4 .abort
	then ;
\ }}}
: try								
	\\ compile || compile cr compile yellow compile . compile blue compile . 	\ TODO if debug-vm
	' | compile | compile, >name [compile] literal 
	\\ compile | compile count compile type 					\ TODO
	compile ?VmReadWrite ; immediate

: VmRead	try vmread ;
: VmWrite	try vmwrite _ ;


: ?VmxRes							\ ( ZF CF name -- 0=sucesss | 1=fail ) {{{
	<<< -if -if _ else
		white count type bl emit yellow ." faulted, result "
		vminstruction_error VmRead blue . norm cr
		8470cafe 600df00d1 .abort then
	else _ red count type bl emit " failed" cr
		8470cafe badf00d1 .abort
	then ;
\ }}}
: try
	' | compile, >name [compile] literal compile ?VmxRes ; immediate

\\ Launch

\ VMCS
page vmcs
vmcs :: 'vmcs var

\ VM
page vm1
vm1 :: 'vm1 var

\ Host VM Entry and Exit
page h-stack
h-stack 1000 + cell - :: h-sp val

page g-stack
g-stack 1000 + cell - :: g-sp val

: status,	66 ` c7 ` 04 ` 25 ` 00 ` 80 ` 0b ` 00 ` ;
:: .status	code 66 ` 89 ` 0c ` 25 ` 00 ` 80 ` 0b ` 00 ` _, ret,

: restart,	rtmp (restart) mov.i, rtmp push, ret, ;
:: restart	code restart, 

:: h-exit	code status, 48 ` 4f ` sti, restart, hlt, -3 sjmp,
\ :: g-entry	code -2 sjmp,
:: g-entry	code status, 47 ` 3f ` restart, -2 sjmp,

\ Host and guest MSRs {{{1

\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ AAA BBB to run under Linux 
:: host_msrs adr
: AAAAAAAAA
EFER 	| , msr ,
STAR 	| , msr ,
LSTAR 	| , msr ,
CSTAR  	| , msr ,
FMASK 	| , msr ,
FS_BASE | , msr ,
GS_BASE | , msr ,
KERNEL_GS_BASE | , msr ,
TSC_AUX | , msr ,
;
here host_msrs - 8/ 2/ :: #host_msrs val

:: guest_msrs adr
: BBBBBBBBBBB
EFER 	, 0 ,
STAR 	, 0 ,	
LSTAR 	, 0 ,
CSTAR 	, 0 ,
FMASK 	, 0 ,
FS_BASE	, 0 ,
GS_BASE	, 0 ,
KERNEL_GS_BASE , 0 ,
TSC_AUX	, 0 ,
;
here guest_msrs - 8/ 2/ :: #guest_msrs val

: VmWriteMsr
	host_msrs	vmexit_msr_load_addr  	VmWrite
	#host_msrs	vmexit_msr_load_count 	VmWrite

	guest_msrs	vmexit_msr_store_addr 	VmWrite
	#guest_msrs	vmexit_msr_store_count 	VmWrite

	guest_msrs	vmentry_msr_load_addr	VmWrite
	#guest_msrs	vmentry_msr_load_count	VmWrite
;
\ }}}

\ Entering VMX root operation
: VmxOn
	cr4 VMXE or cr4! 
	cr0 VM0S msr or VM0R msr and cr0!
	cr4 VM4S msr or VM4R msr and cr4!
	VBAS msr vmcs 4!

	'vmcs try vmxon
;

: VmInit
	VBAS msr vm1 4!

	'vm1 try vmclear
	'vm1 try vmptrld
;
: VmLaunch
	'vm1 try vmlaunch
;
: VmCtrls
	0 
	VBAS msr #55 bit set? if 048d else 0481 then msr 2mask
	0 full 32bit control VmWrite \ pin_exec_ctrl

	0 #31 bit reset						\ Table 26-6:	no secondary controls
	VBAS msr #55 bit set? if 048e else 0482 then msr 2mask
	1 full 32bit control VmWrite \ proc_exec_ctrl

	0  #9 bit set  #21 bit set				\ Table 26-14:	64-bit host, load EFER
	VBAS msr #55 bit set? if 048f else 0483 then msr 2mask
	6 full 32bit control VmWrite \ primary_exit_ctrl

	0  #9 bit set  						\ Table 26-17:	64-bit guest
	VBAS msr #55 bit set? if 0490 else 0484 then msr 2mask
	9 full 32bit control VmWrite \ primary_entry_ctrl
;

: VmHostState
	\ TODO #0 #1 #2 are defined in CORE. reconsider
	cr0	0 full natural host VmWrite
	cr3	1 full natural host VmWrite
	cr4	2 full natural host VmWrite

	h-sp 		#10 full natural host VmWrite
	['] h-exit	#11 full natural host VmWrite

	cs	1 full 16bit host VmWrite
	ds	0 full 16bit host VmWrite
	ds	2 full 16bit host VmWrite
	ds	3 full 16bit host VmWrite
	ds	4 full 16bit host VmWrite
	ds	5 full 16bit host VmWrite
	tr@ _	6 full 16bit host VmWrite
	
	FS_BASE msr 	3 full natural host VmWrite
	GS_BASE msr 	4 full natural host VmWrite
	1000	 	5 full natural host VmWrite

	gdt@ >< _	6 full natural host VmWrite
	idt@ >< _	7 full natural host VmWrite

	EFER msr	1 full 64bit host VmWrite
;

: VmGuestState
	cr0 _ 80010033	0 full natural guest VmWrite
	cr3	1 full natural guest VmWrite
	cr4 _ 00002668 2 full natural guest VmWrite

	cs	1 full 16bit guest VmWrite
	ds	0 full 16bit guest VmWrite
	ds	2 full 16bit guest VmWrite
	ds	3 full 16bit guest VmWrite
	ds	4 full 16bit guest VmWrite
	ds	5 full 16bit guest VmWrite
	tr@ _	7 full 16bit guest VmWrite

	EFER msr _ 0d00	3 full 64bit guest VmWrite

	1000	 	#10 full natural guest VmWrite

	gdt@ >< _	#11 full natural guest VmWrite
	idt@ >< _ 	#12 full natural guest VmWrite
	
	00000002	#16 full natural guest VmWrite 	\ flags
	-1		0 full 64bit guest VmWrite	\ vmcs link pointer

	g-sp		#14 full natural guest VmWrite
	['] g-entry	#15 full natural guest VmWrite

	-1	0 full 32bit guest VmWrite		\ segment limits
	-1	1 full 32bit guest VmWrite
	-1	2 full 32bit guest VmWrite
	-1	3 full 32bit guest VmWrite
	-1	4 full 32bit guest VmWrite
	-1	5 full 32bit guest VmWrite

	67	7 full 32bit guest VmWrite
	ffff	8 full 32bit guest VmWrite
	3ff	9 full 32bit guest VmWrite

							\ Table B-10. Table 26-2. Format of Access Rights
	0 0 bit set 1 bit set 3 bit set 4 bit set 7 bit set #13 bit set #15 bit set
		#11 full 32bit guest VmWrite

	0 0 bit set 1 bit set 4 bit set 7 bit set #14 bit set #15 bit set
		| #10 full 32bit guest VmWrite
		| #12 full 32bit guest VmWrite
		| #13 full 32bit guest VmWrite
		| #14 full 32bit guest VmWrite
		| #15 full 32bit guest VmWrite _


	0 0 bit set 1 bit set 3 bit set 7 bit set
		#17 full 32bit guest VmWrite

	0 1 bit set 7 bit set
		#16 full 32bit guest VmWrite
;
: VmExit? vmexit_reason VmRead ;
: VmRun
	VmxOn VmInit VmCtrls
	VmHostState 
	VmGuestState
	VmLaunch
;

0 :: 'g-0 var
: h-0 notrace	cr yellow ."  HOST >" VmExit? white ."  VM exit reason " yellow . cr  quit ;
: g-0 purple	cr purple ." GUEST >" ['] h-0 warm quit ;
' g-0 | 'g-0 ! warm

: VmResume
	g-sp		#14 full natural guest VmWrite
	['] g-entry	#15 full natural guest VmWrite

	['] g-0 warm

	'vm1 try vmresume

	['] h-0 warm	\ on failure restore host console?
;

VmRun 
