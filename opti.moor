\
\\ Optimizer
\
								\\ Optimizer states
\ :: REGALLOCING		:state				\ TODO: Dirty hack, see comment in core.moor
:: ASSEMBLING		:state
:: DEALLOCING		:state
								\\ Regallocing and assembling states
' : : :		[ compile, ] 
		interpretation latest behavior REGALLOCING latest does ;

: REGALLOCING!! REGALLOCING state!! xexit [			\ ';' is not used to avoid execution of (ending)
interpretation latest behavior REGALLOCING latest does
interpretation latest behavior ASSEMBLING  latest does

: ASSEMBLING!! ASSEMBLING state!! xexit [
interpretation latest behavior REGALLOCING latest does

: DEALLOCING!! DEALLOCING state!! xexit [
interpretation latest behavior REGALLOCING latest does

: regalloc 							\ ( xt -- )		Run XT in REGALLOCING state
	REGALLOCING state! execute interpreting! interpretation state! ;

								\\ Register allocation
:: #regs     10 val						\ Number of CPU registers
:: regs      adr #regs allot					\ Register alias count
:: used-regs adr #regs allot					\ Used registers
:: save-regs adr #regs allot					\ Save registers
: #r       regs + c@ ;						\ ( r -- #r )		Returns number of references for a register
: ^        | #regs >= if . abort" invalid register" then
           | regs + | c@ 1+ >< c!  used-regs + 1 >< c! ;	\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        | #regs >= if . abort" invalid register" then
           regs + | c@ | if 1- >< c!				\ ( r -- )		Decrements reference count for a register. TODO: Or just use cells, not bytes
           else a11a501 .abort then ;
: v^       regs + | c@ | if 1- | if >< c! 0 else _ _ 1 then 	\ ( r -- 1|0 )		If register is not aliased, then it can be reused
           else a11a502 .abort then ;
								\ 			otherwise decrement reference count and return 0
: ?^       regs #regs for | c@ I >< -leave _ 1+ over		\ ( -- r | ABORT )	Allocates a new register, if one is available
           0add bada110c .abort
           then >< _ #regs >< - | ^ ;
: ∧        | ^ ;						\ ( r -- r )		Increments reference count for a register, leaving register on the stack
: ∨        v ;							\ ( r -- )		Decrements reference count for a register
: |∨       | v ;						\ ( r -- r )		Decrement reference count for a register, leaving register on the stack
: ∨∧       | v^ ;						\ ( r -- r 1|0 )	Free register and reallocate it, if it's not aliased. If aliased, returns 1
: ?∧       ?^ ;
: ⊻        1- { ∨ } ;						\ ( r # -- #-1 )	Frees a register
\ : &^       | #r 1- if _ ?^ then ;				\ ( r -- r|r` )         Returns the same register if it has exactly one reference, or a new one
\ : &∧       &^ ;
: ∨?∧      ∨∧ if else _ ?∧ then ;				\ ( r -- r|r')		Allocates new register, if R is aliased

: .regs    regs #regs for | c@ . 1+ over _ ;
: .used-regs used-regs #regs for | c@ . 1+ over _ ;

								\\ Stacks for control structures
: dirupload #|>>s ; 
: revupload #->>s ; 	
: offload   | if for ∨ over else _ then ;
: diroffload dirupload offload ;				\ ( an ... a1 n -- an ... a1 n )	Decrease reference count for registers in sequence
: revoffload revupload offload ;

: download | s> | { | if for | s> ∧ >< over _ else _ _ then } ; \ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements off the specified stack onto the data stack
: onload   s#>> ;						\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements w/o changing references

:: tmp-stack 100 stack						\ Temporary stack, for transfers between other stacks
: >tmp    tmp-stack >s ;
: tmp>    tmp-stack s> ;

:: ret-stack 100 stack						\ Return stack
: >ret    ret-stack >s ;
: ret>    ret-stack s> ;
: #ret@	  ret-stack |{ #s >< - 1- } s#@ ;
: #ret!   ret-stack |{ #s >< - 1- } s#! ;

:: cyc-stack 100 stack						\ Cycle stack
: >cyc    cyc-stack >s ;
: cyc>    cyc-stack s> ;

:: phi-stack 100 stack						\ Phi junction stack
: >phi    phi-stack >s ;
: phi>    phi-stack s> ;

								\\ Variables
:: opt-definition     0 var					\ Definition currently being optimized
:: opt-debug          0 var					\ Specifies whether debug output is enabled
:: opt-index          0 var					\ Index inside current word
:: opt-index-thru     0 var					\ Index throughtout whole optimization process
:: opt-index-word     0 var					\ Index of the beginning of the word
:: opt-index-last     0 var					\ Last index in the current register allocation and assembling invocation
:: opt-nest-level     0 var					\ Word nesting level
:: opt-nest-level-max 0 var
:: opt-lit            0 var					\ Holds 1-cell literal, offset or other data between regallocing and assembling
:: opt-str-adr        0 var					\ Address of the latest compiled string
:: opt-str-size       0 var					\ Size, in cells, of the latest compiled string
:: opt-xt             0 var					\ Holds XT of the currently executing REGALLOCING/ASEMBLING word
:: opt-branch         0 var					\ Holds latest branch offset
:: opt-phi-move       0 var					\ Flag indicating whether φ requires moving regiters
:: opt-phi-temp-reg   0 var					\ Temporary register for φ moves
:: opt-phi-save-reg   0 var					\ Saved register for φ moves
:: opt-phi-dest-reg   0 var					\ Register to be assigned from the saved register
:: opt-phi-forward    0 var					\ Flag indicating whether the φ-junction is forward or backward

:: opt-pass         0 var					\ Optimization pass
:: OPT-PASS-INITCODEGEN 0 val					\ 0 = Initial code generation
:: OPT-PASS-BRANCHLEN   2 val					\ 2 = Branch length optimization (can run multiple times)

								\\ Branch fixup
:: #labels 1000 val						\ TODO: Check if running out of label space. Need '>' to be implemented			
:: label-offset adr #labels cells allot	
:: branch-size adr #labels allot

:: #nest-levels 20 val						\ Number of nest levels; increase as needed
:: thru-indexes adr #nest-levels #labels * cells allot		\ Mapping from (opt-nest-level, opt-index) to opt-index-thru
: thru-indexes-clear
	thru-indexes
	#nest-levels #labels * cells 
	0 fill ;
: 'thru-index-of						\ ( opt-nest-level opt-index -- 'opt-index-thru )	Get offset inside the thru index array
	>< 1- #labels * + cells thru-indexes + ;
: thru-index-of	 'thru-index-of @ ;				\ ( opt-nest-level opt-index -- opt-index-thru )	Get thru index based on nest level and local index
: thru-index-of! 'thru-index-of ! ;				\ ( opt-index-thru opt-nest-level opt-index --  )	Set thru index based on nest level and local index
: opt-thru-index-of!
	opt-index-thru @ opt-nest-level @ opt-index @ 
	thru-index-of! ;

:: start-adr-prologue 0 var					\ Address of the prologue, which is compiled before the word
:: start-adr 0 var						\ Address of the beginning of compiled word (16-bytes aligned preferably)

: opt-index-word!  opt-index @ opt-index-word ! ;
: opt-index+	opt-index 1+! opt-index-thru 1+! ;
: label-offset@ cells label-offset + @ ; 			\ ( index -- ofs )
: label-offset! opt-pass @ OPT-PASS-INITCODEGEN = if
		  start-adr @ here >< - 
		  label-offset opt-index-thru @ cells + !
	        then ;
: branch-is-short@ branch-size + c@ ;				\ ( index -- 1|0 )	Returns whether the compiled branch at index is short (1) or long (0)
: branch-is-short! branch-size + 1 >< c! ;			\ ( index -- )		Marks branch as short
: shift-label-offsets						\ ( shift start-label -- )	Increase label offsets by SHIFT starting with the specified label
          | cells label-offset + >< opt-index-last @ ><
	  - | if for
	  	| @ | 1+ if >>| + >< | <<< ! else _ then cell+
	  over _ else _ _ then _ ;
: shift-offsets?						\ ( shift -- ) 		Shift label offsets starting with 
          opt-index-thru @ branch-is-short@ if _ else
          opt-index-thru @ 1+ shift-label-offsets 
	  opt-index-thru @ branch-is-short! then ;  
: ofs-is-long 							\ ( ofs -- 1|0)	Return 0 if ofs is [-128d, 127d]
          ffffffffffffff80 and | if ffffffffffffff80 - then ;


:: bfx-stack 100 stack						\ Branch fixup stack
: >bfx    bfx-stack >s ;
: bfx>    bfx-stack s> ;

: branch-adr cells label-offset + @ start-adr @ + ;		\ ( index -- adr )	Returns absolute address for the index
: branch-mark  opt-nest-level @ yellow . bs | purple . norm >bfx here >bfx ;			\ ( branch-index -- )	Puts current code address and branch index onto the branch fixup stack
: branch-resolve branch-adr >| - >< 4 - 4! ;			\ ( addr index -- )	Fixes branch offset at ADDR-4, generating offset pointing to branch-index
: branch-offset	 branch-adr here - ;				\ ( index -- )		Computes offset in bytes between HERE and byte offset of instruction at index
: fixup-branches begin bfx> bfx> | 1+ while branch-resolve  repeat _ _ ;

: .((     compile opt-debug compile @ [compile] if ; immediate  \			Words between .(( and )) will be executed if opt-debug flag is set
: ).(     [compile] else ; immediate
: ))      [compile] then ; immediate

								\\ Debug output
: .dump
  cr ." ==== " opt-definition @ .name cr
  start-adr @ | here >< - 22 emit dump 22 emit cr ;

: .dump-thru-indexes
	."     " purple
	opt-index-last @ | if for opt-index-last @ I -
		.bl
	over else _ then 
	norm cr
	opt-nest-level-max @ | if for opt-nest-level-max @ I - 1+
		| yellow .bl bs norm ." : " green
		opt-index-last @ | if for | opt-index-last @ I - 
			\ >< .bl .bl ." - " 
			thru-index-of | 0 <> if .bl else _ ."    " then
		over _ else _ then
		norm cr
	over else _ then
;

: %.debug  \ .((							\ ( xt -- )		Debug print word name and stack
           cr
	   opt-index-thru @ green .bl bs
	   opt-nest-level @ yellow .bl bs
	   opt-index @ purple .bl norm
           1b emit 5b emit 30 emit 39 emit 47 emit
           >name count white type norm

           1b emit 5b emit 31 emit 37 emit 47 emit
	   \ ).( _ )) 
	   ;

: %.S      \ .((
           1b emit 5b emit 32 emit 33 emit 47 emit
           ..S
           1b emit 5b emit 33 emit 39 emit 47 emit
	   blue .regs norm
           1b emit 5b emit 37 emit 32 emit 47 emit
	   52 emit 3a emit bl emit ret-stack .stack
           1b emit 5b emit 38 emit 32 emit 47 emit
	   43 emit 3a emit bl emit cyc-stack .stack
           1b emit 5b emit 38 emit 38 emit 47 emit
	   cf emit 86 emit 3a emit bl emit phi-stack .stack
           1b emit 5b emit 31 emit 30 emit 39 emit 47 emit
	   54 emit 3a emit bl emit tmp-stack .stack
           1b emit 5b emit 31 emit 32 emit 36 emit 47 emit
           ." ¦ "
           1b emit 5b emit 31 emit 32 emit 38 emit 47 emit
	   \ .(( ).( 
	   	\ opt-index-thru @ green .0 label-offset opt-index-thru @ | 0 = if _ _ -1 else 1- cells + @ then white .0 here .. 
	   	opt-index-thru @ green .0 label-offset opt-index-thru @ cells + @ white .0 here .. 
           \ ))
	   \ )) 
	   ;

: %.used-regs  \ .(( 
           cr
           1b emit 5b emit 33 emit 39 emit 47 emit
	   yellow .used-regs norm cr
	   \ )) 
	   ;

								\\ Regallocing semantics definitions
: noop ;

: $ 			        				\ ( "<name>" --  )	Creates new semantics for assembling state
           here 10 aligned here!
           here exec ASSEMBLING ' does
	   compile interpreting!
	   ] ;
: $;       compile ASSEMBLING!! compile xexit [compile] [ ; immediate

: assm     ;
$ assm     $;

: %        
           here exec REGALLOCING ' | >r does 			\ ( "<name>" --  )	Creates new semantics for register allocation state,
           ASSEMBLING     ['] assm behavior ASSEMBLING r> | >r does
           interpretation ['] assm behavior DEALLOCING r> | >r does r>
           compile interpreting! 				\			which equals to execution semantics of its constituents
	   | opt-xt !
	   compile label-offset! 
	   compile opt-index-word!
	   compile opt-thru-index-of!

	   [compile] literal
	   compile %.debug
           ] ;

: %;       
           compile %.S						

           compile ASSEMBLING!!
           opt-xt @
	   compile,
	   compile interpreting!

           compile DEALLOCING!!
           opt-xt @
	   compile,
	   compile interpreting!

	   compile opt-index+

	   compile REGALLOCING!!

	   compile xexit 
	   [compile] [
; immediate

: ;%								\			Finish REGALLOCING definition and start DEALLOCING definition
           [compile] %;
           here exec DEALLOCING opt-xt @ does
	   compile interpreting!
	   ] ; immediate

: ;%;
	   compile REGALLOCING!!

	   compile xexit [compile] [ ; immediate

								\\ DOES> for optimization
:: opt-does-xt	0 var

: optimization-does<	
	REGALLOCING does<
	| opt-does-xt ! 
	compile label-offset!
	compile opt-index-word!
	compile opt-thru-index-of!
	compile | compile %.debug
; immediate

: >optimization-does
	compile opt-index+
	compile REGALLOCING!!
	>does 
; immediate


	   							\\ Register allocation primitives

								\\ Service words
% noop %;

% raise %;							\\ TODO: ABORT?
% doabort %;					

								\\ Nested words
interpretation ' noop behavior REGALLOCING ' exit does
interpretation ' noop behavior ASSEMBLING ' exit does
interpretation ' noop behavior DEALLOCING ' exit does

interpretation ' exit behavior REGALLOCING ' xexit does
interpretation ' exit behavior ASSEMBLING ' xexit does
interpretation ' exit behavior DEALLOCING ' xexit does

\ interpretation ' (beginning) behavior REGALLOCING ' (beginning) does
interpretation ' (beginning) behavior ASSEMBLING ' (beginning) does
interpretation ' (beginning) behavior DEALLOCING ' (beginning) does

\ interpretation ' (ending) behavior REGALLOCING ' (ending) does
\ interpretation ' exit behavior ASSEMBLING ' (ending) does
interpretation ' exit behavior DEALLOCING ' (ending) does

interpretation ' interpreting! behavior REGALLOCING ' interpreting! does
interpretation ' interpreting! behavior ASSEMBLING ' interpreting! does
interpretation ' interpreting! behavior DEALLOCING ' interpreting! does

interpretation ' trace behavior REGALLOCING ' trace does

:: opt-index-stack 8 stack
: >opt-index	opt-index @ opt-index-stack >s 0 opt-index ! ;
: opt-index>	opt-index-stack s> opt-index ! ;



here exec REGALLOCING ' (beginning) ] interpreting!                opt-nest-level 1+!  opt-nest-level @ opt-nest-level-max !  >opt-index                       REGALLOCING state!! xexit [ does
here exec REGALLOCING ' (ending)    ] interpreting! opt-index+     opt-nest-level 1-!                                         opt-index> opt-index 1+!   r> _  REGALLOCING state!! xexit [ does

\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

								\\ Register allocation
% |        1+ { | ∧ } %;					\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ %;							\ ( r # -- #-1)

% ><       { >< } %;						\ ( r1 r2 # -- r2 r2 # )
% <<<      { <<< } %;						\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      { >>> } %;						\ ( r1 r2 r3 # -- r2 r3 r1 # )
% >|       1+ { >| ∧ } %;				 	\ ( r1 r2 # -- r1 r2 r1 #+1 )
% >>|      1+ { >>| ∧ } %;				 	\ ( r1 r2 r3 # -- r1 r2 r3 r1 #+1 )
% >|>|     1+ 1+ { >|>| ∧ >< ∧ >< } %;

% (>r)		1- { >ret } %;
% (r>)		1+ { ret> } %;

% locals(	%;
% -locals-	%;
% )locals	%;
% #l@		@skip >< 1+ { #ret@ ∧ } %;
% #l!		@skip >< 1- { | #ret! ∨ } %;


% lit      @skip | opt-lit ! .(( .. ).( _ )) 1+ { ?∧ } ;% opt-index+ ;%;	\ ( # -- r #+1 )	Allocates new register

% (")      (")-skip >< | opt-str-adr ! - cell/ opt-str-size ! 
           1+ { ?∧ } ;%
           opt-str-size @ for opt-index+ over ;%;

% count    1+ { ?∧ } %;
% emit     ;% ⊻ ;%;						\ ( r # -- #-1 )	Frees the parameter
% type     ;% ⊻ ⊻ ;%;

% branch   @skip 1+ | opt-branch ! .(( .. ).( _ ))   ;% opt-index+ ;%;		\ ( -- )
% ?branch  @skip 1+ | opt-branch ! .(( .. ).( _ )) ⊻ ;% opt-index+ ;%;		\ ( r # -- #-1 )
% -?branch @skip 1+ | opt-branch ! .(( .. ).( _ )) ⊻ ;% opt-index+ ;%;		\ ( r # -- #-1 )

% (if)     >< { 1- phi-stack revupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (if-post) %;
% (else-pre) 
           tmp-stack diroffload %;
% (else-post)
           phi-stack download
	   phi-stack revoffload
	   phi-stack download
	   tmp-stack download
	   phi-stack revoffload %;
% (then)   %;
% (then-post) %;
% (begin)  phi-stack revupload %;				\			Upload stack as it is now
% (until)  %;
% (again)  %;
% (ahead)  %;
% (while)  >< { 1- phi-stack revupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (-leave) >< { 1-
           tmp-stack revupload
	   phi-stack onload
	   tmp-stack onload
	   phi-stack revupload #_
	   phi-stack revupload #_ } >< 1+
           @skip | opt-branch ! .. ⊻ ;% opt-index+ ;%;
% (repeat-pre)
           phi-stack download
	   tmp-stack revoffload %;
% (repeat-post)
           offload
	   tmp-stack download %;
% (continue) %;
% (break)  %;
% (for)    1- { | ∧ | >cyc } 					\ ( r # -- #-1 )	Takes counter off the stack TODO: Save counter on another stack
           <<< { { phi-stack revupload } } >>> ;%
           { _ ∨ } ;%;
% (for-post) %;
% I        1+ { cyc> ∧ | >cyc } %;
% (over)   @skip | opt-branch ! .. ;% opt-index+
           { cyc> ∨ } ;%;
% (over-post) %;

: %alloc-rd
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else
	   ?∧ then then ;

\\ Abstract out for AND, XOR etc
% +        { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% -        { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% and      { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% or       { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% =        { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% <        { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% >        { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% >=       { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% <=       { %alloc-rd } 1+ ;%					\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
	   { { _ _ } } 1- 1- ;%;				\ ( -- rd #-1 )

% sar      							\ ( rd rshift # -- rd rd' rshift #+1 )
           { { | ∨?∧ } } 1+ ;%
	   { ∨ >< _ } 1- 1- ;%;				        \ ( rd'#-1 )

% 1+       { | ∨?∧ } ;% { >< _ } ;%;				\ 			Increment and decrement do not change register allocation
% 1-       { | ∨?∧ } ;% { >< _ } ;%;				\			Although, a new register is allocated if the destination is aliased

% c!       ;% ⊻ ⊻ ;%;			 			\ ( rs rd # -- #-2 )
% !        ;% ⊻ ⊻ ;%;			 			\ ( rs rd # -- #-2 )
% @	   1+ { | ∨?∧ } ;% { >< _ } 1- ;%;

: %val     opt-lit ! 1+ { ?∧ } ;				\ ( # -- r #+1 )	Allocates new register for the value
% baremetal?	baremetal?	%val %;
% bl	   	bl		%val %;
% testing  	testing		%val %;
% test-result   test-result	%val %;

								\\ Stubs to ignore debug output words in the optimizer for now
% ,        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter

% ??       %;							\ ( r # -- #-1 )	Frees the parameter
% ..       ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% .        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% .S %;
% yellow   %;
% norm     %;


								\\ Assembling
								\ Arithmetic and logic
								
								\ CAUTION! Assembling words should leave the stack as it was passed, do not add or drop items!
								\          Deallocing semantics should set up the stack properly, if needed

: .---     cr %.S ;
: .label   opt-nest-level @ |
           yellow .bl bs purple >< | .bl bs 
	   thru-index-of green .bl norm ;
: .inst    green count type norm tab ;				\ ( str -- )		Print instruction string
: .lit     blue . norm ;

: .r       yellow ." r" . bs norm ;
: .r.b     .r yellow ." b" norm ;
: .r,      .r ." , " ;
: .r.b,    .r.b ." , " ;
: .rr      .r, .r ;
: .rr.b    .r.b, .r.b ;
: .rm      .r, yellow ." [r" . bs ." ] " norm ;
: .mr      yellow ." [r" . bs ." ] , " .r norm ;
: .rm.b    .r.b, yellow ." [r" . bs ." ] " norm ;
: .mr.b    yellow ." [r" . bs ." ] , " .r.b norm ;

: .mov     " mov" .inst ;
: .mov.rr   .mov .rr ;
: .mov.rm   .mov .rm ;
: .mov.mr   .mov .mr ;
: .mov.b.rr .mov .rr.b ;
: .mov.b.rm .mov .rm.b ;
: .mov.b.mr .mov .mr.b ;


: ¦        >< ;							\ Swap source and destination registers, in optimizer they are in reverse order compared to assembler

								\\ Prologue and epilogue
: prologue,							\ ( an ... a1 n -- )	Based on input parameters and used register map compiles a prologue
	" |," .inst |, cr %.S
	used-regs #regs for | c@ if				\			Push all used registers, but not parameters and outputs
	" push" .inst | used-regs - | .r push,
	cr { %.S }
	then 1+ over _

	| if for						\			Load input parameters from Forth stack into registers
	" load" .inst | .r
	#_1 >< load, off,
	cr %.S
	over else _ then
	cr %.S
;

: epilogue,
	| if for						\			Store output parameters onto Forth stack
	" store" .inst | .r
	| #_0 >< store, on, ∨
	cr %.S
	over else _ then

	used-regs #regs + 1- #regs for | c@ if			\			Push all pushed registers (not parameters and outputs)
	" pop" .inst | used-regs - | .r pop,
	cr { %.S }
	then 1- over _

	" _," .inst _, cr %.S					\			Move TOS into rtop, if needed

	" ret" .inst ret, cr %.S
;

								\\ Assembling

' var : var [ compile, ] 
	optimization-does< 
		{ 1+ { ?∧ } 
			%.S
		}
		{ >| }
		.((
			>< .mov .r, ..
		).(
			mov.i, 
		))
	>optimization-does
;

' val : val [ compile, ] 
	optimization-does< 
		{ 1+ { ?∧ } 
			%.S
		}
		@ { >| }
		.((
			>< .mov .r, ..
		).(
			mov.i, 
		))
	>optimization-does
;

$ noop	.(( " nop" .inst ).( nop, )) $;

$ @									\ ( rs rd )
	{ || .(( .--- .mov.rm
	).(  ¦ mov.rm, ))
	} $;

$ !	{ || .(( .--- .mov.mr
	).( ¦ mov.mr, ))
	} $;

$ c!	{ || .(( .--- .mov.b.mr
	).( ¦ mov.b.mr, ))
	} $;

: $compare								\ ( rs1 rs2 rd )
	<<< ||
	.((
		.---  >< " cmp" .inst .rr
	).(
		cmp,
	))
	>>>
;
: $comp									\ ( inst-str flag -- )
	( :inst-str :flag )
	{
	$compare
	|
	.((
		| .---  :inst-str .inst .r.b
		| .---  " movzx" .inst .r, .r.b
	).(
		| :flag setf,
		| movzx,
	))

	} 
	return
;

$ =	" setf.e"  .e   $comp $;
$ <>	" setf.ne" .ne  $comp $;
$ <	" setf.l"  .l   $comp $;
$ >	" setf.g"  .g   $comp $;
$ <=	" setf.le" .le  $comp $;
$ >=	" setf.ge" .ge  $comp $;

$ sar								\ ( rd-orig rd-alloc rshift # -- <unchanged> )
	{
		<<<						\ ( rshift rd-orig rd-alloc )
		|| <> if
		|| .(( .--- .mov.rr ).( ¦ mov, ))
		then
		>>>						\ ( rd-orig rd-alloc rshift )
		| rcx <> if
		.(( .--- " push" .inst rcx .r ).( rcx push, ))
		| .(( .--- rcx .mov.rr ).( rcx ¦ mov, ))
		then
		|| >< 
		.(( .--- " sar" .inst .r, rcx .r.b ).( sar, ))
		rcx <> if 
		.(( .--- " pop" .inst rcx .r ).( rcx pop, ))
		then

	} $;

$ +
	{ >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble +
	if							\			RD <> RS1, RS2		mov rd, rs1	add rd, rs1
	{ >|>| } | { <<< }
	>>> >< >|
	.(( .--- .mov.rr .--- " add" .inst .rr
	).( ¦ mov, ¦ add, ))
	else							\			RD = RS2
	<<< >|>|
	.(( .--- " add" .inst .rr
	).( ¦ add, ))
	then
	else							\			RD = RS1
	<<< >|>|
	.(( .--- " add" .inst .rr
	).( ¦ add, ))
	then } $;

$ and
	{ >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble AND
	if							\			RD <> RS1, RS2		mov rd, rs1	and rd, rs1
	{ >|>| } | { <<< }
	>>> >< >|
	.(( .--- .mov.rr .--- " and" .inst .rr
	).( ¦ mov, ¦ and, ))
	else							\			RD = RS2
	<<< >|>|
	.(( .--- " and" .inst .rr
	).( ¦ and, ))
	then
	else							\			RD = RS1
	<<< >|>|
	.(( .--- " and" .inst .rr
	).( ¦ and, ))
	then } $;

$ or
	{ >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble AND
	if							\			RD <> RS1, RS2		mov rd, rs1	and rd, rs1
	{ >|>| } | { <<< }
	>>> >< >|
	.(( .--- .mov.rr .--- " or" .inst .rr
	).( ¦ mov, ¦ or, ))
	else							\			RD = RS2
	<<< >|>|
	.(( .--- " or" .inst .rr
	).( ¦ or, ))
	then
	else							\			RD = RS1
	<<< >|>|
	.(( .--- " or" .inst .rr
	).( ¦ or, ))
	then } $;

$ - 
	{ >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble -
	if							\			RD <> RS1, RS2		mov rd, rs1	sub rd, rs1
	{ >|>| } | { <<< }
	>>> >|
	.(( .--- .mov.rr .--- " sub" .inst .rr
	).( ¦ mov, ¦ sub, ))
	else							\			RD = RS2
	>< <<< >|
	.(( .--- " sub" .inst .rr .--- " neg" .inst .r
	).( ¦ sub, neg, ))
	then
	else							\			RD = RS1
	<<< >|>|
	.(( .--- " sub" .inst .rr
	).( ¦ sub, ))
	then } $;

$ 1+
	{ >|>| - if >|>|					\ ( rs rd )
	.(( .mov.rr .---
	).( ¦ mov, ))
	then |
	.(( " inc" .inst .r
	).( inc, ))
	} $;

$ 1-
	{ >|>| - if >|>|					\ ( rs rd )
	.(( .mov.rr .---
	).( ¦ mov, ))
	then |
	.(( " dec" .inst .r
	).( dec, ))
	} $;

$ lit
	{ |  opt-lit @ ><					\ ( rd )
	.(( .mov .r, .lit
	).( ¦ mov.i, ))
	} $;

$ (")
	{ |  opt-str-adr @ ><					\ ( rd )
	.(( .mov .r, .lit
	).( ¦ mov.i, ))
	} $;
$;

$ count								\ ( r-adr r-count )
	{ ||
	.(( .---  " movzx.b" .inst .r, norm ." byte ptr [" norm .r norm ." ]"
	).( movzx.m, ))
	} $;


ASSEMBLING ' lit behavior
	||	ASSEMBLING ' baremetal?		does
	||	ASSEMBLING ' bl			does
	||	ASSEMBLING ' testing		does
	||	ASSEMBLING ' test-result	does
	__

:: <emit>	\ ( c=rdi )
	code
	r11 push,
	rax push,
	rcx push,
	rdx push,
	rsi push,
	rdi push,

	rdi push,
	rsi rsp mov,
	rax 1 mov.i,
	rdx rax mov,
	rdi rax mov,
	syscall,
	rdi pop,

	rdi pop,
	rsi pop,
	rdx pop,
	rcx pop,
	rax pop,
	r11 pop,
	ret,

:: <type>	\ ( adr=rdi count=rsi )
	code
	r11 push,
	rax push,
	rcx push,
	rdx push,
	rsi push,
	rdi push,

	rdi push,

	rax 1 mov.i,
	rdx rsi mov,
	rsi rdi mov,
	rdi rax mov,
	syscall,

	rdi pop,

	rdi pop,
	rsi pop,
	rdx pop,
	rcx pop,
	rax pop,
	r11 pop,
	ret,

$ emit								\ ( rs )
	{ |
	.(( " emit" .inst .r
	).(
	| rdi <> if
		rdi push,
		| rdi >< mov,
	then
	['] <emit> here 5 + - lcall,
	| rdi <> if
		rdi pop,
	then
	_
	))
	} $;
$ type								\ ( r-adr r-count )
	{ ||
	.(( " type" .inst >< .r, .r
	).(

	rdi push,
	rsi push,

	push,
	push,
	rdi pop,
	rsi pop,

	['] <type> here 5 + - lcall,

	rsi pop,
	rdi pop,
	))
	} $;

$ doabort
	.(( " abort" .inst
	).(
	(abort) here 5 + - ljmp,
	))
$;

$ raise
	.(( " raise" .inst
	).(
	(abort) here 5 + - ljmp,
	))
$;

								\\
								\\ φ-junction
								\\

: φ
           1 opt-phi-move !
	   -1 opt-phi-save-reg !
	   -1 opt-phi-temp-reg !
	   -1 opt-phi-dest-reg !
           | phi> | >phi
	   - if
		   fee bad57ac .abort
	   else
		   phi-stack download
		   phi-stack dirupload
		   phi-stack diroffload
		   tmp-stack dirupload
		   _
		   phi> | if for
			   phi> >|>|
			   - if
				   opt-phi-move @ if
					   0 opt-phi-move !
					   ?∧ opt-phi-temp-reg !
					   |  opt-phi-temp-reg @
					   .(( .mov.rr .--- ).( ¦ mov, ))
					   | opt-phi-save-reg !
					   .(( .mov.rr .--- ).( ¦ mov, ))
				   else
					   >| opt-phi-save-reg @ - if
						   .(( .mov.rr .--- ).( ¦ mov, ))
					   else
						   | opt-phi-dest-reg !
						   _ _
					   then
				   then
			   else
				   _ _
			   then
		   over else _ then
		   opt-phi-dest-reg @ 1+ if
		   	   opt-phi-temp-reg @ opt-phi-dest-reg @
			   .(( .mov.rr .--- ).( ¦ mov, ))
		   then
		   opt-phi-move @ if else opt-phi-temp-reg @ ∨ then
		   opt-phi-forward @ if tmp-stack onload offload else tmp-stack onload then
		   phi-stack onload
		   opt-phi-forward @ if phi-stack revupload #_ phi-stack download else #_ then
           then
	   ;

: <φ       0 opt-phi-forward ! φ ;
: >φ       1 opt-phi-forward ! φ ;

								\ Control

$ (if)     { | |
           .(( " test" .inst .rr
	   ).( ¦ test, ))
	   } $;
$ (if-post) $;

$ ?branch  
           opt-branch @ opt-index @ + 1+
           .(( " jz " .inst .label
	   ).(
	   opt-pass @
	   | OPT-PASS-INITCODEGEN = if _
	   	0 .z lj, branch-mark
	   else
	   | OPT-PASS-BRANCHLEN = if _
	        opt-nest-level @ >< thru-index-of
	   	| label-offset@ 
		ofs-is-long if label-offset@ here 6 + start-adr @ - - .z lj, 
		else
		-4 shift-offsets?
		label-offset@ 
		here 2 + start-adr @ - - .z j, 
		then
	   then 
	   then 
	   ))
	   $;

$ -?branch 
           opt-branch @ opt-index @ + 1+
           .(( " jnz" .inst .label
	   ).(
	   opt-pass @
	   | OPT-PASS-INITCODEGEN = if _
	   	0 .nz lj, branch-mark
	   else
	   | OPT-PASS-BRANCHLEN = if _
	        opt-nest-level @ >< thru-index-of
	   	| label-offset@
		ofs-is-long if label-offset@ here 6 + start-adr @ - - .nz lj, 
		else
		-4 shift-offsets?
		label-offset@
		here 2 + start-adr @ - - .nz j, 
		then
	   then 
	   then 
	   ))
	   $;

$ branch   
           opt-branch @ opt-index @ + 1+
           .(( " jmp" .inst .label
	   ).( 
	   opt-pass @
	   | OPT-PASS-INITCODEGEN = if _
	   	0 ljmp, branch-mark
	   else
	   | OPT-PASS-BRANCHLEN = if _
	        opt-nest-level @ >< thru-index-of
	   	| label-offset@
		ofs-is-long if label-offset@ here 5 + start-adr @ - - ljmp, 
		else
		-3 shift-offsets?
		label-offset@
		here 2 + start-adr @ - - sjmp, 
		then
	   then 
	   then
	   ))
	   $;


$ (for)    { >|>| - if
           >|>|
	   .(( .mov.rr
	   ).( ¦ mov, ))
           then } $;
$ (over)
           {
	   cyc> | >cyc
	   .(( " dec" .inst .r .---
	   ).( dec, ))
           opt-index-thru @ 2+
	   .(( " jz" .inst .label .---
	   ).(
	   opt-pass @
	   | OPT-PASS-INITCODEGEN = if _
	   	0 .z lj, branch-mark
	   else
	   | OPT-PASS-BRANCHLEN = if _
	   	| label-offset@
		ofs-is-long if label-offset@ here 6 + start-adr @ - - .z lj, 
		else
		-4 shift-offsets?
		label-offset@
		here 2 + start-adr @ - - .z j, 
		then
	   then
	   then
	   ))
	   }
           <φ
           { .---
           opt-branch @ opt-index @ + 1+
	   .(( " jmp" .inst .label
	   ).(
	   opt-pass @
	   | OPT-PASS-INITCODEGEN = if _
	   	0 ljmp, branch-mark
	   else
	   | OPT-PASS-BRANCHLEN = if _
	        opt-nest-level @ >< 1+ thru-index-of
	   	| label-offset@
		ofs-is-long _ 1 if		\ TODO: Dirty hack, jz above does not know if this branch will be short or long and generates wrong target. 
			label-offset@ here 5 + start-adr @ - - ljmp,
		else
		\\ This code is never executed now, jump back is always long
		abort" (over) short branch optimization should never be performed"
		then
	   then
	   then
	   ))
	   } $;

$ (while)  { | |
           .(( " test" .inst .rr
	   ).( ¦ test, ))
	   } $;

$ (then)   >φ $;
$ (again)  <φ $;
$ (repeat-pre) <φ $;
$ (repeat-post) $;
								
								\\ Register allocation and assembling
: regalloc-init							\ ( -- )		Initializes array of referenced registers
           regs #regs 0 fill
	   label-offset #labels cells -1 fill
	   branch-size #labels 0 fill
	   here start-adr-prologue !
	   here start-adr !
	   tmp-stack empty
	   ret-stack empty
	   cyc-stack empty
	   phi-stack empty
	   bfx-stack empty
	   -1 -1 >bfx >bfx
           rsp ∧ _						\ 			RSP should not be used as a general-purpose register
	   rstack0 ∧ _
	   rstack ∧ _
           used-regs #regs 0 fill
;

: :^       regalloc-init ;
: ^.>
           1 opt-debug !

	   OPT-PASS-INITCODEGEN opt-pass !
	   0 opt-index !
	   0 opt-index-word !
           cr %.S
	   ' regalloc
	   \\ ['] exit %.debug %.S %.used-regs
;

: optimize 
           ( :xt )
           :xt opt-definition !

           thru-indexes-clear
           0 opt-nest-level-max !

           0 opt-debug !
	   cr white ." PASS=0a Register allocation" norm
	   OPT-PASS-INITCODEGEN opt-pass !
	   0 opt-index !
	   0 opt-index-thru !
	   0 opt-index-word !
	   0 opt-nest-level !
	   tmp-stack dirupload
	   cr %.S
	   :xt regalloc
	   opt-index-thru @ opt-index-last !
	   fixup-branches
	   cr %.used-regs %.S
	   cr .dump
           cr .dump-thru-indexes

           1 opt-debug !
	   cr white ." PASS=1a Initial code generation DEBUG" norm
	   OPT-PASS-BRANCHLEN opt-pass !
	   0 opt-index !
	   0 opt-index-thru !
	   0 opt-index-word !
	   0 opt-nest-level !
	   offload
	   cr %.S
	   tmp-stack download
	   tmp-stack dirupload
	   cr %.S
	   start-adr @ here!
	   :xt regalloc
	   \\ ['] exit %.debug %.S %.used-regs
	   cr .dump

           0 opt-debug !
	   cr white ." PASS=1b Branch length optimization" norm
	   OPT-PASS-BRANCHLEN opt-pass !
	   0 opt-index !
	   0 opt-index-thru !
	   0 opt-index-word !
	   0 opt-nest-level !
	   offload
	   tmp-stack download
	   tmp-stack dirupload
	   cr %.S
	   start-adr @ here!
	   :xt regalloc
	   \\ ['] exit %.debug %.S %.used-regs
	   cr .dump
	

           0 opt-debug !
	   cr white ." PASS=2 Final code generation" norm
	   OPT-PASS-BRANCHLEN opt-pass !
	   0 opt-index !
	   0 opt-index-thru !
	   0 opt-index-word !
	   0 opt-nest-level !
	   offload
	   cr %.S
	   tmp-stack download
	   tmp-stack dirupload
	   cr %.S
	   start-adr @ here!
	   tmp-stack onload
	   cr %.S
	   prologue,
	   cr %.S

	   here  start-adr @ - 0 shift-label-offsets
	   :xt regalloc
	   cr %.S
	   epilogue,
	   \\ ['] exit %.debug %.S %.used-regs
	   cr .dump

           return
;

: ^>       ' optimize ;

