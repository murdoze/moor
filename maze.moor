\
\\ Maze generator, v 2
\\

vocabulary maze
maze definitions

\\ Maze

\ Maze entities
:: EMPTY	3000 val
:: WALL		1f9ee val

\ Generation order
:: LEFT		char L val
:: RIGHT	char R val
:: UP		char U val
:: DOWN		char D val

:: M-total-rows	1 var
:: M-total-cols	1 var

\ Cells reserved for maze, width and height notwithstanding
:: M-cells		18000	val
:: M-max-row-len	100	val
:: M-max-col-len	100	val

:: M adr M-cells cells allot
: M-init	M M-cells for | EMPTY >< ! cell+ over _ ;
M-init

\ Random row and column indices
:: M-row-indices adr M-max-row-len cells allot
:: M-col-indices adr M-max-col-len cells allot
:: M-gen-order   adr M-max-row-len M-max-col-len + cells allot

\ We gonna draw many small mazes within one giant maze
:: M-left	0 var
:: M-top	0 var
:: M-cols	1 var
:: M-rows	1 var

: 'M	( :row :col )
	:row M-total-cols @ * :col + cells M +
	return ;

: M-total-size!	
	( :rows :cols )
	:rows 1 and 0 = 		if abort" Number of rows must be odd" then 
	:cols 1 and 0 = 		if abort" Number of cols must be odd" then 
	:rows :cols * M-cells > 	if abort" Maze too big, increase buffer size" then
	:cols M-total-cols !
	:rows M-total-rows !
	return ;

: M-maze!
	( :left :top :cols :rows )
	:cols M-max-col-len @ >		if abort" Too many cols" then
	:rows M-max-row-len @ >		if abort" Too many rows" then

	:cols :left + M-total-cols @ >	if abort" Maze size and position exceeds total cols" then
	:rows :top +  M-total-rows @ >	if abort" Maze size and position exceeds total rows" then

	:left M-left !
	:top  M-top  !
	:cols M-cols !
	:rows M-rows !
	return ;

: .M	0 0 ( :row :col )
	M-total-rows @ | for | I - :row!
		bl emit
		M-total-cols @ | for | I - :col! 
			:row :col 'M @ uemit
		over _
		cr
	over _
	return
;

\ Maze drawing
:: Δcol		0 var
:: Δrow		0 var
:: curr-col	0 var
:: curr-row	0 var
:: last-col	0 var
:: last-row	0 var

:: row-index	0 var
:: col-index	0 var
:: Δrow-index	0 var
:: Δcol-index	0 var

: left!		-1 Δcol !  0 Δrow ! 	M-cols @ 1- curr-col !	0 last-col ! 		-1 last-row ! ;
: right!	 1 Δcol !  0 Δrow ! 	       0 curr-col !	M-cols @ last-col !	-1 last-row ! ;
: up!		 0 Δcol ! -1 Δrow ! 	M-rows @ 1- curr-row !	0 last-row ! 		-1 last-col ! ;
: down!		 0 Δcol !  1 Δrow ! 	       0 curr-row !	M-rows @ last-row !	-1 last-col ! ;

: draw-direction!					\ ( dir -- )	Set draw direction
	| LEFT	= if left!	 0 Δcol-index !	 1 Δrow-index !	else
	| RIGHT = if right!	 0 Δcol-index !	 1 Δrow-index !	else
	| UP	= if up!	 1 Δcol-index !	 0 Δrow-index !	else
	| DOWN	= if down!	 1 Δcol-index !	 0 Δrow-index !	else	uemit abort" : invalid draw direction"
	then then then then _ ; 

: draw
	begin
		curr-row @ last-row @ = if exit then
		curr-col @ last-col @ = if exit then

		curr-row @ Δrow @ + M-top  @ +
		curr-col @ Δcol @ + M-left @ + 
		'M @ WALL <> if
			WALL
			curr-row @ M-top  @ +
			curr-col @ M-left @ +
			'M ! 
			
			curhome .M
			\ key [char] q = if abort then 
			\ curr-col @ 2* 1+ curr-row @ at WALL uemit
		then
		Δcol @ curr-col @ + curr-col !
		Δrow @ curr-row @ + curr-row !

	again
;

: draw-sequence
	0 col-index !
	0 row-index !

	M-gen-order M-rows @ 2- 2/ 1- M-cols @ 2- 2/ 1- +
	for
		M-row-indices row-index @ cells + @ 2* 2+ curr-row !
		M-col-indices col-index @ cells + @ 2* 2+ curr-col !

		| @ draw-direction! draw

		row-index @ Δrow-index @ + row-index !
		col-index @ Δcol-index @ + col-index !

		cell+
	over
	_
;

: draw-borders
	0 curr-row ! left! draw
	M-rows @ 1- curr-row ! right! draw
	0 curr-col ! down! draw
	M-cols @ 1- curr-col ! up! draw
;

: uemit-seq	
	( :adr :n )					\ Emit sequence
	:adr :n for | @ uemit cell+ over _
	return ;


: M-draw-gen-wall-order
	\ Generate indices
	M-row-indices M-rows @ 2- 2/ || nseq || rseq _ _  
	M-col-indices M-cols @ 2- 2/ || nseq || rseq _ _

	\ Generate drawing order
	M-gen-order
	M-rows @ | 1 and >< 1+ 2/ 2/ >< - 	for |  LEFT >< ! cell+ over
	M-rows @ 2- 2/ 2/ 			for | RIGHT >< ! cell+ over
	M-cols @ | 1 and >< 1+ 2/ 2/ >< -	for |    UP >< ! cell+ over
	M-cols @ 2- 2/ 2/			for |  DOWN >< ! cell+ over
	_

	M-gen-order M-rows @ 2- 2/ 1- M-cols @ 2- 2/ 1- + rseq
;





\\ Testing

: MAZE
	#19 #25 M-total-size!

	cursoff
	clrscr
	curhome

	margins? 1- -1 and 1 or 2- >< -1 and 1 or 2/ -1 and 1 or 2- M-total-size!
	M-init

	#27 M-rows ! #20  M-top  !
	#27 M-cols ! #20 M-left !
	draw-borders
	M-draw-gen-wall-order
	draw-sequence

	M-total-rows @ M-rows !
	M-total-cols @ M-cols !
	0 M-top !
	0 M-left !
	draw-borders
	M-draw-gen-wall-order
	draw-sequence

	cr
	curson
; \ latest typecheck

\ forth definitions

